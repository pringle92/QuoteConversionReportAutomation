// C# 10+ Features
namespace conversionTest;

// --- Global Usings ---
using Microsoft.Extensions.Configuration;
using System;
using System.Diagnostics;
using System.Drawing; // Keep for Color
using System.IO;
using System.IO.Pipes;
using System.Text; // Keep for Encoding
using System.Windows.Forms;
using System.Threading;
using System.Threading.Tasks; // Keep for Task
using ReportWrapperCommon;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq; // Added for JSON manipulation
using JR.Utils.GUI.Forms; // Added for FlexibleMessageBox
using System.Globalization; // Added for date parsing/formatting
using Microsoft.Win32; // Added for Registry access
using QuoteConversionReportAutomation;

/// <summary>
/// Represents the main form of the Quote Conversion Report Automation application.
/// Includes manual report generation and an optional automated daily run feature.
/// Handles user interactions, orchestrates report generation and processing,
/// communicates with a Crystal Report wrapper via Named Pipes, and sends email notifications.
/// Uses MenuStrip for Dark Mode toggle and Help. Status updates split between left/right labels.
/// Reads and writes the last auto-run date to appsettings.json.
/// Disables controls during auto-run.
/// </summary>
public partial class Form1 : Form
{
    #region Fields and Properties

    // Dependencies
    /// <summary>Provides access to application configuration settings.</summary>
    private readonly IConfiguration _configuration;
    /// <summary>Utility for sending emails.</summary>
    private readonly EmailUtility _emailUtility;

    // Application Info
    /// <summary>Current version of the application.</summary>
    private const string AppVersion = "1.5.0"; // Fixed UI state reset, status reset, view button logic, and integrated FlexibleMessageBox.

    // State Variables
    /// <summary>Stores the file path of the raw Excel report generated by the Crystal Report wrapper (output of Button 1).</summary>
    private string _generatedReportPath = string.Empty;
    /// <summary>Stores the file path of the final processed Excel analysis file (output of Button 2).</summary>
    private string _generatedAnalysisFilePath = string.Empty;
    /// <summary>Stores the date the application was loaded, used for default date calculations.</summary>
    private DateTime _today;
    /// <summary>Stores the current financial year string (e.g., "2023_24"), initialized in Form1_Load.</summary>
    private string _financialYear = string.Empty;
    /// <summary>Flag to prevent concurrent execution of the automated daily task.</summary>
    private bool _isAutoRunTaskExecuting = false;
    /// <summary>Tracks the date of the last successful automated daily run to prevent multiple runs per day. Loaded from appsettings.json.</summary>
    private DateTime _lastAutoRunDate = DateTime.MinValue;
    /// <summary>Tracks if the "Done for today" status has been set to prevent repeated logs/UI updates.</summary>
    private bool _autoRunStatusSetForToday = false;
    /// <summary>Tracks the date for which the _autoRunStatusSetForToday flag is valid.</summary>
    private DateTime _autoRunStatusDate = DateTime.MinValue;


    private static readonly string appSettingsBasePath = "\\\\harlow.local\\DFS\\IT Department\\Applications\\Development 2025\\QuoteConversionReportAutomation\\conversionTest";
    /// <summary>Path to the application settings file.</summary>
    private readonly string _appSettingsPath = Path.Combine(appSettingsBasePath, "appsettings.json");

    // Report Type Constants (Indices must match the order in reportTypeComboBox Items: Daily, Weekly, Monthly, Quarterly, Annual)
    /// <summary>Index for the Daily report type in the reportTypeComboBox.</summary>
    private const int DailyReportIndex = 0;
    /// <summary>Index for the Weekly report type in the reportTypeComboBox.</summary>
    private const int WeeklyReportIndex = 1;
    /// <summary>Index for the Monthly report type in the reportTypeComboBox.</summary>
    private const int MonthlyReportIndex = 2;
    /// <summary>Index for the Quarterly report type in the reportTypeComboBox.</summary>
    private const int QuarterlyReportIndex = 3;
    /// <summary>Index for the Annual report type in the reportTypeComboBox.</summary>
    private const int AnnualReportIndex = 4;

    // --- Theme Colors ---
    // Dark Mode
    private readonly Color _darkModeBackColor = Color.FromArgb(45, 45, 48);
    private readonly Color _darkModeForeColor = Color.White;
    private readonly Color _darkModeButtonBackColor = Color.FromArgb(63, 63, 70);
    private readonly Color _darkModeTextBoxBackColor = Color.FromArgb(60, 60, 63);
    private readonly Color _darkModeMenuBackColor = Color.FromArgb(60, 60, 63); // Dark background for menus
    private readonly Color _darkModeMenuForeColor = Color.White; // White text for menus

    private readonly Color _darkModeCheckBoxBackColor = Color.FromArgb(45, 45, 48);
    // Light Mode
    private readonly Color _lightModeBackColor = SystemColors.Control;
    private readonly Color _lightModeForeColor = SystemColors.ControlText;
    private readonly Color _lightModeButtonBackColor = SystemColors.Control;
    private readonly Color _lightModeTextBoxBackColor = SystemColors.Window;
    private readonly Color _lightModeMenuBackColor = SystemColors.Control; // Default menu background
    private readonly Color _lightModeMenuForeColor = SystemColors.ControlText; // Default menu text
    // Auto Run Button Specific Colors
    private readonly Color _autoRunEnabledColor = Color.LightGreen;
    private readonly Color _autoRunDisabledColor = Color.LightCoral; // Light Red


    // Configuration Properties
    /// <summary>Gets the path to the Crystal Report file (.rpt) from configuration.</summary>
    private string CrystalReportLocation => _configuration["settings:CrystalReportPath"] ?? string.Empty;
    /// <summary>Gets the full path to the Crystal Report Wrapper executable from configuration.</summary>
    private string WrapperExePath => Path.GetFullPath(_configuration["settings:WrapperExePath"] ?? "CrystalReportWrapper.exe");
    /// <summary>Gets the process name (without extension) of the Crystal Report Wrapper executable.</summary>
    private string WrapperProcessName => Path.GetFileNameWithoutExtension(WrapperExePath);

    // --- Dynamic Path Properties ---
    /// <summary>
    /// Gets the calculated output path for the raw Crystal Report export file.
    /// This path depends on the currently selected report type in the UI.
    /// The directory structure is created if it doesn't exist.
    /// </summary>
    public string ReportOutputLocation
    {
        get
        {
            string baseDir = $@"C:\Users\{Environment.UserName}\Harlow Printing\IT Projects - Documents\Dashboard Datasets\Raw_data\Quotes conversion\Estimate Reports Exports";
            // Use the selected end date for the filename to match the report content
            string fileName = $"{endDatePicker.Value:yyyyMMdd}_EstimateSuccessReport_Raw.xlsx";
            string subFolder = reportTypeComboBox.SelectedIndex switch
            {
                DailyReportIndex => "Daily Reports",
                WeeklyReportIndex => "Weekly Reports",
                MonthlyReportIndex => "Monthly Reports",
                QuarterlyReportIndex => "Quarterly reports",
                AnnualReportIndex => "Annual Reports",
                _ => "Other Reports",
            };
            string fullPath = Path.Combine(baseDir, subFolder, fileName);
            try
            {
                string? directoryPath = Path.GetDirectoryName(fullPath);
                if (!string.IsNullOrEmpty(directoryPath)) { Directory.CreateDirectory(directoryPath); }
                else { Logger.LogWarning($"Could not determine directory path from '{fullPath}' for raw report output."); }
            }
            catch (Exception ex) { Logger.LogError($"Failed to create directory '{Path.GetDirectoryName(fullPath)}': {ex.Message}"); }
            return fullPath;
        }
    }
    /// <summary>
    /// Gets the calculated path to the appropriate Excel template file (.xlsx).
    /// </summary>
    public string ExcelTemplateLocation
    {
        get
        {
            string baseDir = $@"C:\Users\{Environment.UserName}\Harlow Printing\IT Projects - Documents\Dashboard Datasets\Raw_data\Quotes conversion\TEMPLATE\";
            string templateName = reportTypeComboBox.SelectedIndex switch
            {
                MonthlyReportIndex or QuarterlyReportIndex or AnnualReportIndex => "TEMPLATE_Estimate Success Rate_Monthly.xlsx",
                _ => "TEMPLATE_Estimate Success Rate.xlsx" // Daily and Weekly use the same template
            };
            return Path.Combine(baseDir, templateName);
        }
    }
    /// <summary>
    /// Gets the base directory where the final processed analysis Excel file will be saved.
    /// </summary>
    public static string ExcelFinalSaveLocation
    {
        get { return $@"C:\Users\{Environment.UserName}\Harlow Printing\IT Projects - Documents\Dashboard Datasets\Raw_data\Quotes conversion\Estimates\"; }
    }

    // --- Build Configuration Helper ---
    /// <summary>Gets a value indicating whether the application is running in DEBUG configuration.</summary>
    private static bool IsDebug =>
#if DEBUG
        true;
#else
        false;
#endif

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the <see cref="Form1"/> class.
    /// </summary>
    /// <param name="configuration">The application configuration provider.</param>
    /// <exception cref="ArgumentNullException">Thrown if configuration is null.</exception>
    public Form1(IConfiguration configuration)
    {
        _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
        _emailUtility = new EmailUtility(_configuration);

        Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Form1 Constructor: Initializing components...");
        try
        {
            InitializeComponent();
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Form1 Constructor: InitializeComponent() completed.");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Form1 Constructor: CRITICAL ERROR during InitializeComponent! Exception: {ex}");
            Logger.LogCritical($"CRITICAL ERROR during InitializeComponent: {ex.Message}", ex);
            // Use FlexibleMessageBox for critical startup error
            FlexibleMessageBox.Show($"A critical error occurred initializing the form components:\n\n{ex.Message}\n\nThe application cannot continue.",
                                    "Form Initialization Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            throw; // Re-throw to terminate if initialization fails critically
        }
        Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Form1 Constructor: Exiting.");
    }

    #endregion

    #region Form Load / Closing

    /// <summary>
    /// Handles the Load event of the form. Initializes UI elements, validates configuration,
    /// sets default values, checks the status of the report wrapper service, applies initial theme,
    /// reads the last auto-run date, and wires up auto-run timer.
    /// </summary>
    private async void Form1_Load(object sender, EventArgs e)
    {
        Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Form1_Load: Entered.");
        UpdateStatusMain("Loading application...");
        try
        {
            // Initialize date/year fields
            _today = DateTime.Today;
            _financialYear = ExcelCopyData.GetCurrentFinancialYear(true);
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Form1_Load: Date='{_today:yyyy-MM-dd}', FY='{_financialYear}'");

            Logger.LogInfo("Form Loading...");

            // --- Read Last Auto Run Date ---
            ReadLastRunDate(); // Load the date from appsettings.json

            // --- Configuration Validation ---
            if (string.IsNullOrEmpty(CrystalReportLocation) || !File.Exists(CrystalReportLocation))
            {
                Logger.LogError($"Config 'settings:CrystalReportPath' missing or file not found: '{CrystalReportLocation}'. Report generation disabled.");
                FlexibleMessageBox.Show($"Warning: Crystal Report file path is missing or invalid ('{CrystalReportLocation}').\n\nReport generation (Button 1) will be disabled.",
                                        "Configuration Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                createReportButton.Enabled = false;
            }
            if (string.IsNullOrEmpty(WrapperExePath) || !File.Exists(WrapperExePath))
            {
                Logger.LogError($"Config 'settings:WrapperExePath' missing or file not found: '{WrapperExePath}'. Report generation disabled.");
                FlexibleMessageBox.Show($"Warning: Crystal Report Wrapper executable path is missing or invalid ('{WrapperExePath}').\n\nReport generation (Button 1) will be disabled.",
                                        "Configuration Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                createReportButton.Enabled = false;
            }

            // --- Initial Template Check ---
            // Set default to Daily *before* checking template path
            if (reportTypeComboBox.Items.Count > DailyReportIndex)
                reportTypeComboBox.SelectedIndex = DailyReportIndex;
            else if (reportTypeComboBox.Items.Count > 0)
                reportTypeComboBox.SelectedIndex = 0;

            string initialTemplatePath = ExcelTemplateLocation; // Get path based on initial selection
            if (string.IsNullOrEmpty(initialTemplatePath) || !File.Exists(initialTemplatePath))
            {
                Logger.LogWarning($"Initial Excel template file path (for Daily/Weekly) is missing or invalid ('{initialTemplatePath}'). Processing might fail.");
            }

            // --- UI Initialization ---
            Text = $"Quote Conversion Automation - {(IsDebug ? "DEBUG" : "RELEASE")} - v{AppVersion}";
            StartPosition = FormStartPosition.CenterScreen;

            // Populate Dropdowns
            PopulateFinancialYearDropdown();
            if (financialYearComboBox.Items.Count > 0) financialYearComboBox.SelectedIndex = 0;
            financialYearComboBox.DropDownStyle = ComboBoxStyle.DropDownList;

            // Report Type Dropdown already handled above
            reportTypeComboBox.DropDownStyle = ComboBoxStyle.DropDownList;

            // --- Theme & Menu Setup ---
            // Check Windows theme setting
            bool useDarkMode = IsWindowsDarkModeEnabled();
            darkModeToolStripMenuItem.Checked = useDarkMode; // Set menu item state *before* applying theme
            ApplyTheme(useDarkMode); // Apply theme based on Windows setting

            // --- Auto Run Setup ---
            // Event handlers wired in designer
            UpdateAutoRunUI(dailyCheckTimer.Enabled); // Initial UI update based on timer default (false)


            // Trigger SelectedIndexChanged AFTER setting up theme and auto-run UI
            // This will set the initial date pickers correctly for the default Daily selection
            reportTypeComboBox_SelectedIndexChanged(reportTypeComboBox, EventArgs.Empty); // Use correct name

            // Initial button states (Button 1 state handled by config check, Button 2 by SelectedIndexChanged)
            processEmailButton.Enabled = false;
            viewReportButton.Visible = false;
            viewAnalysisButton.Visible = false;

            // --- Ensure Wrapper Service is Running ---
            UpdateStatusMain("Checking report service...");
            await EnsureWrapperIsRunningAsync();

            Logger.LogInfo("Form Load Initialisation Complete.");
            UpdateStatusMain("Ready");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Form1_Load: CRITICAL ERROR! Exception: {ex}");
            Logger.LogCritical($"CRITICAL ERROR during Form_Load: {ex.Message}", ex);
            FlexibleMessageBox.Show($"A critical error occurred loading the application:\n\n{ex.Message}\n\nThe application may not function correctly.",
                                    "Application Load Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            UpdateStatusMain("Error during load.");
        }
    }

    /// <summary>
    /// Handles the FormClosing event. Ensures the background wrapper process is terminated
    /// and stops the auto-run timer.
    /// </summary>
    private void Form1_FormClosing(object sender, FormClosingEventArgs e)
    {
        dailyCheckTimer.Stop(); // Stop the timer
        TerminateWrapperProcess(); // Terminate background service
    }

    #endregion

    #region Event Handlers (Async)

    /// <summary>
    /// Handles the Click event for Button 1 (Create Report).
    /// Validates input, ensures the wrapper service is running, sends a request via Named Pipes,
    /// and updates the UI based on the response.
    /// </summary>
    private async void createReportButton_Click(object sender, EventArgs e)
    {
        // Disable action buttons and inputs, keep AutoRun toggle enabled
        SetActionButtonsEnabled(false);
        SetOtherControlsEnabled(false);
        createReportButton.Text = "Requesting...";
        UpdateStatusMain("Validating request...");
        Logger.LogDebug("Create Report Button Clicked: Requesting Crystal Report generation.");

        using var cts = new CancellationTokenSource(TimeSpan.FromMinutes(6));

        try
        {
            if (!ValidateInputDates()) { ResetUIOnError("Date Error"); return; }
            if (!ValidateFinancialYearSelection()) { ResetUIOnError("FY Mismatch"); return; }
            if (string.IsNullOrEmpty(CrystalReportLocation) || !File.Exists(CrystalReportLocation))
            { throw new InvalidOperationException("Crystal Report location is invalid or file not found."); }
            if (string.IsNullOrEmpty(WrapperExePath) || !File.Exists(WrapperExePath))
            { throw new InvalidOperationException("Crystal Report Wrapper executable location is invalid or file not found."); }

            UpdateStatusMain("Checking report service...");
            if (!await EnsureWrapperIsRunningAsync(cts.Token))
            { throw new InvalidOperationException($"Failed to start or connect to the report service ({WrapperProcessName})."); }

            string reportOutputPath = ReportOutputLocation; // Get path based on current UI state
            var request = new ReportRequest
            {
                CrystalReportLocation = CrystalReportLocation,
                ReportOutputLocation = reportOutputPath,
                ReportDateFrom = startDatePicker.Value,
                ReportDateTo = endDatePicker.Value
            };

            UpdateStatusMain("Connecting to report service...");
            Logger.LogInfo("Attempting Named Pipe communication...");
            ReportResponse? response = await SendRequestReceiveResponseAsync(request, cts.Token);

            if (response?.Success == true && !string.IsNullOrEmpty(response.OutputPath) && File.Exists(response.OutputPath))
            {
                _generatedReportPath = response.OutputPath;
                Logger.LogInfo($"Report generated successfully by wrapper: {_generatedReportPath}");
                UpdateStatusMain("Report created successfully.");
                createReportButton.Text = "Report Created";
                createReportButton.Enabled = false; // Keep Button 1 disabled after success
                processEmailButton.Enabled = true;  // Enable Button 2
                viewReportButton.Visible = true;
                viewReportButton.Enabled = true; // Ensure view button is enabled
                viewAnalysisButton.Visible = false;
                _generatedAnalysisFilePath = string.Empty;
                SetOtherControlsEnabled(true); // Re-enable secondary controls
                // Keep AutoRun button enabled
                SafeControlUpdate(toggleAutoRunButton, () => { toggleAutoRunButton.Enabled = true; });
            }
            else
            {
                string errorMessage = response?.ErrorMessage ?? "Unknown error from report service.";
                if (response?.Success == true && (string.IsNullOrEmpty(response.OutputPath) || !File.Exists(response.OutputPath)))
                { errorMessage = $"Report service indicated success, but the output file path ('{response?.OutputPath ?? "NULL"}') is invalid or the file does not exist."; Logger.LogError(errorMessage); }
                throw new Exception($"Report generation failed: {errorMessage}");
            }
        }
        catch (OperationCanceledException)
        {
            Logger.LogWarning("Report generation request cancelled or timed out.");
            FlexibleMessageBox.Show("The report generation request timed out or was cancelled.", "Timeout / Cancelled", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            ResetUIOnError("Cancelled");
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error during Create Report operation: {ex}");
            FlexibleMessageBox.Show($"An error occurred while requesting the report:\n\n{ex.Message}", "Report Request Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            ResetUIOnError("Error");
        }
    }


    /// <summary>
    /// Handles the Click event for Button 2 (Process & Email).
    /// Checks if a final report already exists, processes the raw report using ExcelCopyData,
    /// handles optional manual refresh steps, sends the completion email, and updates the UI.
    /// </summary>
    private async void processEmailButton_Click(object sender, EventArgs e)
    {
        // Disable action buttons and inputs, keep AutoRun toggle enabled
        SetActionButtonsEnabled(false);
        SetOtherControlsEnabled(false);
        processEmailButton.Text = "Processing...";
        UpdateStatusMain("Starting Excel processing...");
        Logger.LogDebug("Process & Email Button Clicked: Processing Excel report.");

        using var cts = new CancellationTokenSource(TimeSpan.FromMinutes(15));
        var token = cts.Token;

        IProgress<ProgressReport> excelProgress = new Progress<ProgressReport>(report => UpdateStatusMain(report.Message));
        IProgress<string> emailProgress = new Progress<string>(message => UpdateStatusMain(message));

        string? finalFilePath = null;
        int reportType = reportTypeComboBox.SelectedIndex;
        bool requiresManualRefresh = reportType is MonthlyReportIndex or QuarterlyReportIndex or AnnualReportIndex;
        string baseSaveLocation = ExcelFinalSaveLocation;
        DateTime reportDate = endDatePicker.Value; // Use the end date from the picker

        try
        {
            // *** Call GetExpectedFinalFilePath WITH the date argument ***
            string? expectedFinalPath = ExcelCopyData.GetExpectedFinalFilePath(reportType, baseSaveLocation, reportDate);
            if (expectedFinalPath != null && File.Exists(expectedFinalPath))
            {
                Logger.LogWarning($"Expected final file already exists: {expectedFinalPath}");
                DialogResult dr = FlexibleMessageBox.Show( // Use FlexibleMessageBox
                    $"The report file '{Path.GetFileName(expectedFinalPath)}' already exists for this period.\n\n" +
                    "Do you want to skip processing and send this existing file?",
                    "File Already Exists", MessageBoxButtons.YesNo, MessageBoxIcon.Question);

                if (dr == DialogResult.Yes)
                {
                    Logger.LogInfo("User chose to send existing file.");
                    finalFilePath = expectedFinalPath;
                    _generatedAnalysisFilePath = finalFilePath;
                    ShowViewAnalysisButton(true); // Ensure button is visible and enabled

                    bool proceedToEmail = true;
                    if (requiresManualRefresh)
                    {
                        UpdateStatusMain("Waiting for manual Excel refresh...");
                        proceedToEmail = await HandleManualExcelRefreshAsync(finalFilePath, token);
                        if (!proceedToEmail) { UpdateStatusMain("Manual refresh/confirmation cancelled."); ResetUIOnError("Cancelled"); return; }
                        UpdateStatusMain("Manual refresh confirmed. Preparing email...");
                    }
                    if (proceedToEmail) { await SendCompletionEmailAsync(finalFilePath, emailProgress, token); }
                    else { ResetUIOnError("Create Report"); } // Reset UI if email is skipped after manual refresh
                    return; // Exit after handling existing file or skipping email
                }
                else
                {
                    Logger.LogInfo("User chose to overwrite/regenerate the existing file.");
                    try
                    { File.Delete(expectedFinalPath); Logger.LogInfo($"Deleted existing file: {expectedFinalPath}"); }
                    catch (Exception delEx)
                    {
                        Logger.LogError($"Failed to delete existing file '{expectedFinalPath}': {delEx.Message}");
                        FlexibleMessageBox.Show($"Could not delete the existing report file:\n{expectedFinalPath}\n\nPlease ensure the file is not open and try again.\n\nError: {delEx.Message}",
                                        "File Deletion Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        ResetUIOnError("File Error"); return;
                    }
                }
            }

            // --- Proceed with generating a new file ---
            string reportToProcessPath = _generatedReportPath;
            string templatePath = ExcelTemplateLocation;
            if (string.IsNullOrEmpty(templatePath) || !File.Exists(templatePath))
            { throw new FileNotFoundException($"The required Excel template file for the selected report type was not found.", templatePath); }
            if (string.IsNullOrEmpty(reportToProcessPath) || !File.Exists(reportToProcessPath))
            { throw new FileNotFoundException("The raw report file to process was not found. Please generate the report first.", reportToProcessPath); }
            if (string.IsNullOrEmpty(baseSaveLocation))
            { throw new InvalidOperationException("The base save location for the final report is not configured correctly."); }

            string financialYear = financialYearComboBox.SelectedItem?.ToString() ?? _financialYear;
            string sourceSheet = "Sheet1";
            string destSheet = "DATA";

            // *** Call ProcessExcelReportAsync WITH the date argument ***
            finalFilePath = await ExcelCopyData.ProcessExcelReportAsync(
                financialYear, reportType,
                reportToProcessPath, sourceSheet, baseSaveLocation, templatePath, destSheet,
                1, 1, excelProgress, reportDate, token); // Pass reportDate

            if (string.IsNullOrEmpty(finalFilePath) || !File.Exists(finalFilePath))
            {
                if (token.IsCancellationRequested) { throw new OperationCanceledException("Excel processing was cancelled."); }
                else { throw new Exception("Excel processing failed to produce a final file. Check logs for details."); }
            }

            _generatedAnalysisFilePath = finalFilePath;
            Logger.LogInfo($"Excel processing completed. Final file: {finalFilePath}");
            UpdateStatusMain("Excel processing complete.");
            ShowViewAnalysisButton(true); // Ensure button is visible and enabled

            bool proceedToEmailAfterGenerate = true;
            if (requiresManualRefresh)
            {
                UpdateStatusMain("Waiting for manual Excel refresh...");
                proceedToEmailAfterGenerate = await HandleManualExcelRefreshAsync(finalFilePath, token);
                if (!proceedToEmailAfterGenerate) { UpdateStatusMain("Manual refresh/confirmation cancelled."); ResetUIOnError("Cancelled"); return; }
                UpdateStatusMain("Manual refresh confirmed. Preparing email...");
            }

            if (proceedToEmailAfterGenerate)
            { await SendCompletionEmailAsync(finalFilePath, emailProgress, token); }
            else { ResetUIOnError("Create Report"); } // Reset UI if email is skipped after manual refresh

        }
        catch (OperationCanceledException)
        {
            Logger.LogWarning("Excel processing or subsequent step cancelled.");
            // UpdateStatusMain("Operation Cancelled."); // ResetUIOnError handles status update
            ResetUIOnError("Cancelled");
        }
        catch (FileNotFoundException fnfEx)
        {
            Logger.LogError($"File not found during Process & Email operation: {fnfEx}");
            FlexibleMessageBox.Show(fnfEx.Message, "File Not Found Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            // UpdateStatusMain("Error: Required file not found."); // ResetUIOnError handles status update
            ResetUIOnError("File Error");
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error during Process & Email operation: {ex}");
            FlexibleMessageBox.Show($"An unexpected error occurred during processing:\n\n{ex.Message}", "Processing Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            // UpdateStatusMain("Error during processing."); // ResetUIOnError handles status update
            ResetUIOnError("Error");
        }
    }


    /// <summary>
    /// Handles the Click event for the "View Report" button.
    /// </summary>
    private void viewReportButton_Click(object sender, EventArgs e)
    {
        if (string.IsNullOrEmpty(_generatedReportPath))
        {
            Logger.LogWarning("View Report clicked, but no raw report path is available.");
            FlexibleMessageBox.Show("The raw report file path is not available. Please generate the report first.", "Information", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            return;
        }
        OpenFileHelper(_generatedReportPath, "raw report output");
    }

    /// <summary>
    /// Handles the Click event for the "View Analysis" button.
    /// </summary>
    private void viewAnalysisButton_Click(object sender, EventArgs e)
    {
        if (string.IsNullOrEmpty(_generatedAnalysisFilePath))
        {
            Logger.LogWarning("View Analysis clicked, but no processed file path is available.");
            FlexibleMessageBox.Show("The processed analysis file path is not available. Please process the report first (Button 2).", "Information", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            return;
        }
        OpenFileHelper(_generatedAnalysisFilePath, "processed analysis file");
    }

    /// <summary>
    /// Handles changes in the Report Type dropdown (reportTypeComboBox).
    /// Updates date pickers and UI visibility based on the selected report type.
    /// **Daily report now uses the previous workday.**
    /// </summary>
    private void reportTypeComboBox_SelectedIndexChanged(object sender, EventArgs e)
    {
        if (sender is not ComboBox comboBox || comboBox.SelectedItem == null) return;

        int selectedIndex = comboBox.SelectedIndex;
        DateTime todayValue = _today; // Use the stored load date for consistency

        // Calculate the date range based on the selected index
        var (dateFrom, dateTo, showFinYear) = selectedIndex switch
        {
            // *** MODIFIED: Use previous workday for Daily ***
            DailyReportIndex => (GetPreviousWorkday(todayValue), GetPreviousWorkday(todayValue), true),
            WeeklyReportIndex => (todayValue.AddDays(-13), todayValue, true), // Stays as today for end date
            MonthlyReportIndex => CalculateMonthlyRange(todayValue),
            QuarterlyReportIndex => CalculateQuarterlyRange(todayValue),
            AnnualReportIndex => (new DateTime(todayValue.Year - 1, 1, 1), new DateTime(todayValue.Year - 1, 12, 31), false),
            _ => (todayValue, todayValue, true) // Default fallback
        };

        Logger.LogInfo($"Report Type changed (Index {selectedIndex}). Range: {dateFrom:d} to {dateTo:d}. ShowFinYear: {showFinYear}");

        // Safely update UI controls
        SafeControlUpdate(startDatePicker, () => { startDatePicker.Value = dateFrom; });
        SafeControlUpdate(endDatePicker, () => { endDatePicker.Value = dateTo; });
        SafeControlUpdate(financialYearLabel, () => { financialYearLabel.Visible = showFinYear; });
        SafeControlUpdate(financialYearComboBox, () =>
        {
            financialYearComboBox.Visible = showFinYear;
            financialYearComboBox.Enabled = showFinYear;
            if (showFinYear && financialYearComboBox.Items.Count == 0)
            { PopulateFinancialYearDropdown(); }
        });

        // Update visibility of Femi checkbox vs Paul label
        bool isDailySelected = (selectedIndex == DailyReportIndex);
        SafeControlUpdate(sendToFemiOnlyCheckBox, () => { sendToFemiOnlyCheckBox.Visible = !isDailySelected; });
        SafeControlUpdate(emailRecipientLabel, () =>
        {
            emailRecipientLabel.Visible = isDailySelected;
            if (isDailySelected) { emailRecipientLabel.Text = "Emailing Daily report to Paul"; Logger.LogDebug("Daily report selected. Showing Paul email label."); }
            else { Logger.LogDebug("Non-Daily report selected. Showing Femi checkbox."); }
        });

        // Check template path for the selected type
        string currentTemplatePath = ExcelTemplateLocation;
        if (string.IsNullOrEmpty(currentTemplatePath) || !File.Exists(currentTemplatePath))
            Logger.LogWarning($"Excel template file for the selected report type ({comboBox.SelectedItem}) is missing or invalid ('{currentTemplatePath}'). Processing might fail.");
        else
            Logger.LogDebug($"Template path for type {selectedIndex}: {currentTemplatePath}");

        // Reset button states as the report parameters have changed
        ResetButtonStatesAfterTypeChange();
    }

    /// <summary>
    /// Handles the Click event for the Auto Run toggle button.
    /// Enables or disables the daily check timer.
    /// Resets the "done for today" flag when manually toggled.
    /// </summary>
    private void toggleAutoRunButton_Click(object sender, EventArgs e)
    {
        dailyCheckTimer.Enabled = !dailyCheckTimer.Enabled;
        _autoRunStatusSetForToday = false; // Reset flag when user manually toggles
        UpdateAutoRunUI(dailyCheckTimer.Enabled); // Update button text/color AND status label
        Logger.LogInfo($"Daily Auto Run {(dailyCheckTimer.Enabled ? "Enabled" : "Disabled")} by user.");
        // No need to explicitly set status here, UpdateAutoRunUI handles it
    }

    /// <summary>
    /// Handles the Tick event for the daily check timer.
    /// Checks if it's time to run the automated daily report (around 8 AM) and if it hasn't run today.
    /// If the report has already run for today, it updates the status once and does nothing further.
    /// The timer continues running to check again the next day.
    /// </summary>
    private async void dailyCheckTimer_Tick(object sender, EventArgs e)
    {
        // Exit immediately if timer disabled or a task is already running
        if (!dailyCheckTimer.Enabled || _isAutoRunTaskExecuting) return;

        DateTime now = DateTime.Now;

        // Reset the "done for today" flag if the date has changed since the last check
        if (now.Date != _autoRunStatusDate)
        {
            _autoRunStatusSetForToday = false;
            _autoRunStatusDate = now.Date;
            // Also reset the status text if the date changed and timer is enabled
            if (dailyCheckTimer.Enabled) UpdateAutoRunUI(true);
        }

        // --- Check 1: Time of Day ---
        if (now.Hour != 8) return; // Check only during the 8 AM hour

        // --- Check 2: Already Run Today? ---
        ReadLastRunDate(); // Re-read in case settings file was modified externally
        if (now.Date <= _lastAutoRunDate.Date)
        {
            // Report has already run for today. Update status only if not already done.
            if (!_autoRunStatusSetForToday)
            {
                Logger.LogInfo($"Auto Run: Check complete for today ({now:yyyy-MM-dd}). Report already ran on {_lastAutoRunDate:yyyy-MM-dd}.");
                UpdateStatusRight($"Auto Run: Done for {now:dd/MM}"); // Indicate check is done for the day
                _autoRunStatusSetForToday = true; // Set flag to prevent repeated updates
                // Update button/color state to reflect enabled but done
                UpdateAutoRunUI(true);
            }
            return; // Exit event handler, timer keeps running
        }

        // --- Prevent multiple triggers within the hour if not yet run ---
        if (_isAutoRunTaskExecuting) return;

        // --- Passed Checks: Time to Run ---
        _isAutoRunTaskExecuting = true; // Set flag
        bool originallyEnabled = dailyCheckTimer.Enabled; // Store timer state before stopping
        dailyCheckTimer.Stop(); // Stop timer *temporarily* during execution
        DisableControlsForAutoRun(); // Disable UI
        UpdateStatusMain("Auto Run: Starting daily report...");
        Logger.LogInfo($"Auto Run: Triggered for today ({now:yyyy-MM-dd}) at {now:HH:mm:ss}. Last run was {_lastAutoRunDate:yyyy-MM-dd}.");

        try
        {
            // *** RunAutomatedDailyReportAsync uses previous workday internally ***
            bool success = await RunAutomatedDailyReportAsync();
            if (success)
            {
                _lastAutoRunDate = now.Date; // Update in-memory date (still track run by *today's* date)
                SaveLastRunDate(_lastAutoRunDate); // Save to appsettings.json
                Logger.LogInfo("Auto Run: Daily report completed successfully.");
                UpdateStatusRight($"Auto Run: Completed {now:dd/MM HH:mm}");
                _autoRunStatusSetForToday = true; // Mark as done for today after successful run
            }
            else
            {
                Logger.LogError("Auto Run: Daily report failed. See previous logs.");
                UpdateStatusRight($"Auto Run: FAILED {now:dd/MM HH:mm}");
                _autoRunStatusSetForToday = true; // Mark as done even if failed to prevent retries today
            }
        }
        catch (Exception ex)
        {
            Logger.LogCritical($"Auto Run: Unhandled exception during automated run: {ex}");
            UpdateStatusRight($"Auto Run: CRITICAL ERROR {now:dd/MM HH:mm}");
            _autoRunStatusSetForToday = true; // Mark as done even if failed critically
            originallyEnabled = false; // Prevent restart on critical error if desired
        }
        finally
        {
            _isAutoRunTaskExecuting = false; // Clear flag

            // --- Decide whether to restart timer AFTER execution ---
            // Only restart if it was originally enabled by the user.
            if (originallyEnabled)
            {
                dailyCheckTimer.Start(); // Restart timer for subsequent days' checks
                Logger.LogDebug("Auto Run: Timer restarted for future checks.");
            }
            else
            {
                Logger.LogDebug("Auto Run: Timer remains stopped as it wasn't originally enabled OR critical error occurred.");
            }

            // --- Now Reset UI ---
            EnableControlsAfterAutoRun(); // Re-enable UI (calls ResetUIOnError -> UpdateAutoRunUI)

            // Update the UI state *again* after potentially restarting the timer.
            // UpdateAutoRunUI is called within EnableControlsAfterAutoRun via ResetUIOnError
            // Explicitly set main status to Ready AFTER UI reset is complete.
            UpdateStatusMain("Ready");
        }
    }


    /// <summary>
    /// Handles the Click event for the Dark Mode menu item. Toggles dark mode.
    /// </summary>
    private void darkModeToolStripMenuItem_Click(object sender, EventArgs e)
    {
        // The CheckOnClick property handles toggling the checked state automatically.
        // We just need to apply the theme based on the new state.
        ApplyTheme(darkModeToolStripMenuItem.Checked);
    }

    /// <summary>
    /// Handles the Click event for the Help menu item. Displays help information using FlexibleMessageBox.
    /// </summary>
    private void helpToolStripMenuItem_Click(object sender, EventArgs e)
    {
        string helpTitle = $"Help - Quote Conversion v{AppVersion}";


        // Use StringBuilder to build the RTF string
        var helpMessageBuilder = new StringBuilder();

        // Append each part of the RTF string.
        // Note: Backslashes need to be escaped (\\) because this is not a verbatim string.
        // AppendLine automatically adds the correct newline characters (\r\n on Windows).
        helpMessageBuilder.AppendLine("{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0 Segoe UI;}}");
        helpMessageBuilder.AppendLine("{\\colortbl ;\\red0\\green0\\blue0;}");
        helpMessageBuilder.AppendLine("\\pard\\sa200\\sl276\\slmult1\\b\\fs24 Quote Conversion Automation Tool\\b0\\fs20\\par");
        helpMessageBuilder.AppendLine("\\par");
        helpMessageBuilder.AppendLine("This tool automates the process of generating and processing Estimate Success Rate reports.\\par");
        helpMessageBuilder.AppendLine("\\par");
        helpMessageBuilder.AppendLine("\\b How to Use:\\b0\\par");
        helpMessageBuilder.AppendLine("\\par");
        helpMessageBuilder.AppendLine("1.  \\b Select Report Type:\\b0  Choose Daily, Weekly, Monthly, Quarterly, or Annual from the dropdown. Dates will adjust automatically.\\par");
        helpMessageBuilder.AppendLine("    * \\b Daily:\\b0 Dates will be set to the \\i previous working day\\i0  (Friday if today is Monday, otherwise yesterday).\\par");
        helpMessageBuilder.AppendLine("    * \\b Weekly/Daily:\\b0 Ensure the correct Financial Year is selected if visible.\\par");
        helpMessageBuilder.AppendLine("\\par");
        helpMessageBuilder.AppendLine("2.  \\b Adjust Dates (Optional):\\b0  You can manually change the 'From' and 'To' dates if needed after selection.\\par");
        helpMessageBuilder.AppendLine("\\par");
        // Escape the quotes within the string
        helpMessageBuilder.AppendLine("3.  \\b Create Raw Report:\\b0  Click the \\\"Create Report\\\" button. This contacts a background service to generate the raw data export from Crystal Reports. Wait for the status to show \\\"Report Created\\\". The filename will reflect the 'To' date.\\par");
        helpMessageBuilder.AppendLine("\\par");
        helpMessageBuilder.AppendLine("4.  \\b Process & Email:\\b0  Once the raw report is created, click the \\\"Process and Email\\\" button. This will:\\par");
        helpMessageBuilder.AppendLine("    * Copy data into the appropriate template.\\par");
        helpMessageBuilder.AppendLine("    * Extract unique customers.\\par");
        helpMessageBuilder.AppendLine("    * Perform calculations.\\par");
        helpMessageBuilder.AppendLine("    * Clean up unused rows.\\par");
        helpMessageBuilder.AppendLine("    * (For Weekly reports) Append data to the central Power BI source file.\\par");
        helpMessageBuilder.AppendLine("    * (For Monthly/Quarterly/Annual) Prompt you to open the file in Excel to Refresh All pivot tables, Save, and Close.\\par");
        helpMessageBuilder.AppendLine("    * Send the final report via email to the configured recipients (or just Paul S. for automated Daily reports). The final filename will reflect the 'To' date.\\par");
        helpMessageBuilder.AppendLine("\\par");
        helpMessageBuilder.AppendLine("5.  \\b View Files (Optional):\\b0  Use the \\\"View Report\\\" and \\\"View Analysis\\\" buttons after the corresponding steps are complete to open the generated files.\\par");
        helpMessageBuilder.AppendLine("\\par");
        helpMessageBuilder.AppendLine("6.  \\b Options Menu:\\b0\\par");
        helpMessageBuilder.AppendLine("    * \\b Dark Mode:\\b0 Toggle the visual theme.\\par");
        helpMessageBuilder.AppendLine("\\par");
        helpMessageBuilder.AppendLine("7.  \\b Auto Run Button:\\b0  Enable/Disable the automated daily report generation (runs around 8 AM for the \\i previous working day\\i0 ). The status is shown on the right of the status bar. The application checks the `appsettings.json` file to avoid running more than once per day. If the report has already run for the day, the timer stops checking until the next day/app restart.\\par");
        helpMessageBuilder.AppendLine("\\par");
        helpMessageBuilder.AppendLine("\\b Troubleshooting:\\b0\\par");
        helpMessageBuilder.AppendLine("\\par");
        helpMessageBuilder.AppendLine("* Ensure the Crystal Report Wrapper service is running (the app tries to start it).\\par");
        helpMessageBuilder.AppendLine("* Check file paths in `appsettings.json` if errors occur finding reports or templates.\\par");
        helpMessageBuilder.AppendLine("* Ensure the central weekly report file is accessible and not locked if appending fails.\\par");
        helpMessageBuilder.AppendLine("* Check the application logs located in the 'Logs' subfolder for detailed error information.\\par");
        helpMessageBuilder.AppendLine("* If auto-run fails to update `appsettings.json`, check file permissions for the application directory.\\par");
        helpMessageBuilder.AppendLine("* If you get an error refreshing a Slicer, remove it, then click into the Pivot table, in the PivotTable Fields on the right, Right Click customers and select add as slicer, move it back to where it was.\\par");
        helpMessageBuilder.Append('}'); // Append the final closing brace without a newline

        // Get the final string from the StringBuilder
        string helpMessage = helpMessageBuilder.ToString();
        //Use FlexibleMessageBox
        FlexibleMessageBox.ShowRtf(helpMessage, helpTitle, MessageBoxButtons.OK, MessageBoxIcon.Information);
    }


    #endregion

    #region Named Pipe Communication (Async)

    /// <summary>
    /// Sends a request object via named pipe and awaits a response object.
    /// Handles serialization, length-prefixing, and timeouts.
    /// </summary>
    /// <param name="request">The ReportRequest object to send.</param>
    /// <param name="cancellationToken">Token to allow cancellation of the operation.</param>
    /// <returns>A Task that represents the asynchronous operation. The task result contains the ReportResponse object, or null on failure/cancellation.</returns>
    /// <exception cref="TimeoutException">Thrown if connecting to the pipe server times out.</exception>
    /// <exception cref="IOException">Thrown if there's an error reading/writing to the pipe.</exception>
    /// <exception cref="InvalidDataException">Thrown if the received response cannot be deserialized.</exception>
    /// <exception cref="Exception">Thrown for other unexpected errors during communication.</exception>
    private async Task<ReportResponse?> SendRequestReceiveResponseAsync(ReportRequest request, CancellationToken cancellationToken)
    {
        const string pipeName = "CrystalReportPipe";
        const int connectTimeoutMs = 5000; // 5 seconds to connect

        Logger.LogDebug($"Connecting to named pipe '{pipeName}'...");
        // Use await using for automatic disposal of the pipe client
        await using var pipeClient = new NamedPipeClientStream(".", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous);

        try
        {
            // Connect with timeout and cancellation support
            await pipeClient.ConnectAsync(connectTimeoutMs, cancellationToken);
            Logger.LogInfo("Connected to pipe server.");
            UpdateStatusMain("Connected. Sending request...");

            // --- Send Request (Length-Prefixed) ---
            // Serialize request to JSON
            string requestJson = JsonConvert.SerializeObject(request);
            byte[] requestBytes = Encoding.UTF8.GetBytes(requestJson);
            // Get length as 4-byte prefix
            byte[] lengthBytes = BitConverter.GetBytes(requestBytes.Length);

            // Write length, then message bytes
            await pipeClient.WriteAsync(lengthBytes, cancellationToken);
            await pipeClient.WriteAsync(requestBytes, cancellationToken);
            await pipeClient.FlushAsync(cancellationToken); // Ensure data is sent immediately
            Logger.LogDebug($"Sent request ({requestBytes.Length} bytes): {requestJson}");
            UpdateStatusMain("Request sent. Waiting for response...");

            // --- Read Response (Length-Prefixed) ---
            // 1. Read the 4-byte length prefix
            byte[] responseLengthBuffer = new byte[4];
            int bytesRead = await ReadPipeAsync(pipeClient, responseLengthBuffer, 0, 4, cancellationToken);
            if (bytesRead < 4) throw new IOException("Failed to read full response length prefix from service.");

            // Convert length bytes to integer
            int responseLength = BitConverter.ToInt32(responseLengthBuffer, 0);
            // Basic validation on received length
            if (responseLength <= 0 || responseLength > 10 * 1024 * 1024) // Max 10MB response sanity check
            { throw new IOException($"Invalid response length received: {responseLength}"); }
            Logger.LogDebug($"Expecting response length: {responseLength}");

            // 2. Read the actual response message bytes
            byte[] responseBuffer = new byte[responseLength];
            bytesRead = await ReadPipeAsync(pipeClient, responseBuffer, 0, responseLength, cancellationToken);
            if (bytesRead < responseLength) throw new IOException("Failed to read complete response message from service.");

            // 3. Decode bytes to string and deserialize JSON
            string responseJson = Encoding.UTF8.GetString(responseBuffer);
            Logger.LogDebug($"Received response ({responseLength} bytes): {responseJson}");
            var response = JsonConvert.DeserializeObject<ReportResponse>(responseJson) ?? throw new InvalidDataException("Failed to deserialize response JSON.");
            UpdateStatusMain("Response received.");
            return response;
        }
        catch (TimeoutException ex) // Catch specific timeout from ConnectAsync
        {
            Logger.LogError($"Timeout connecting to named pipe server '{pipeName}'.");
            // Re-throw with a more user-friendly message
            throw new TimeoutException($"Connection to the report service timed out. Ensure '{WrapperProcessName}' is running.", ex);
        }
        catch (IOException ex) // Catch pipe-related read/write errors
        {
            Logger.LogError($"IO Error communicating with named pipe server: {ex.Message}");
            throw new IOException($"Communication error with the report service: {ex.Message}", ex);
        }
        catch (OperationCanceledException) // Catch cancellation signal
        {
            Logger.LogWarning("Named pipe communication cancelled.");
            throw; // Re-throw cancellation exception
        }
        catch (Exception ex) // Catch other potential errors (serialization, etc.)
        {
            Logger.LogError($"Unexpected error during named pipe communication: {ex}");
            throw new Exception($"An unexpected error occurred communicating with the report service: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Helper method to reliably read an exact number of bytes from a PipeStream asynchronously.
    /// Handles cases where ReadAsync might return fewer bytes than requested in a single call.
    /// </summary>
    /// <param name="pipe">The PipeStream to read from.</param>
    /// <param name="buffer">The buffer to read data into.</param>
    /// <param name="offset">The starting position in the buffer.</param>
    /// <param name="count">The exact number of bytes to read.</param>
    /// <param name="cancellationToken">Token to allow cancellation.</param>
    /// <returns>The total number of bytes read (should equal count on success).</returns>
    /// <exception cref="EndOfStreamException">Thrown if the pipe closes before the requested number of bytes are read.</exception>
    private static async Task<int> ReadPipeAsync(PipeStream pipe, byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        int totalBytesRead = 0;
        while (totalBytesRead < count)
        {
            // ReadAsync can return 0 if the pipe is closed gracefully from the other end.
            int bytesRead = await pipe.ReadAsync(buffer.AsMemory(offset + totalBytesRead, count - totalBytesRead), cancellationToken);
            if (bytesRead == 0)
            {
                // Pipe closed before we could read the expected amount
                throw new EndOfStreamException("The pipe connection was closed prematurely while reading data.");
            }
            totalBytesRead += bytesRead;
        }
        return totalBytesRead;
    }


    #endregion

    #region Manual Excel Refresh Handling (Async)

    /// <summary>
    /// Manages the process of opening the processed Excel file for manual user interaction
    /// (Refresh All, Save, Close). Waits for the user to close Excel before proceeding.
    /// </summary>
    /// <param name="filePath">The path to the Excel file to open.</param>
    /// <param name="token">Token to allow cancellation of the waiting process.</param>
    /// <returns>A Task that represents the asynchronous operation. The task result is true if the user confirms to proceed after closing Excel, false otherwise (including cancellation or errors).</returns>
    private async Task<bool> HandleManualExcelRefreshAsync(string filePath, CancellationToken token)
    {
        Process? excelProcess = null; // Store the started Excel process
        bool userConfirmedProceed = false;

        try
        {
            // --- Check for other running Excel instances ---
            // Run synchronous Process.GetProcessesByName on a background thread to avoid UI freeze
            if (await Task.Run(() => Process.GetProcessesByName("EXCEL").Length > 0, token))
            {
                // Prompt user about closing other instances
                DialogResult closeResult = FlexibleMessageBox.Show( // Use FlexibleMessageBox
                    "Other Excel instances are currently running. It's recommended to close all Excel windows before proceeding to avoid issues.\n\nDo you want the application to attempt closing them?",
                    "Close Other Excel Instances?",
                    MessageBoxButtons.YesNoCancel,
                    MessageBoxIcon.Warning);

                if (closeResult == DialogResult.Cancel) return false; // User cancelled the whole operation
                if (closeResult == DialogResult.Yes)
                {
                    // Attempt to close other Excel processes
                    UpdateStatusMain("Attempting to close other Excel instances...");
                    await Task.Run(() => CloseExcelProcesses(), token); // Run synchronous kill loop in background
                    await Task.Delay(1500, token); // Brief pause after attempting closure
                    UpdateStatusMain("Ready to open report for manual refresh.");
                }
                // If 'No', proceed, but be aware of potential conflicts
            }

            // --- Prompt User with Instructions ---
            FlexibleMessageBox.Show( // Use FlexibleMessageBox
                "The processed report will now open in Excel.\n\n" +
                "*** IMPORTANT ***\n" +
                "1. Go to the Pivot Sheets in Excel.\n" +
                "2. Right Click 'Refresh' for all Pivots & Slicers.\n" +
                "3. Wait for the refresh to complete.\n" +
                "4. SAVE the file!\n" +
                "5. CLOSE Excel completely.\n\n" +
                "The application will wait until Excel is closed.",
                "Manual Refresh Required",
                MessageBoxButtons.OK,
                MessageBoxIcon.Information);

            token.ThrowIfCancellationRequested(); // Check for cancellation before starting process

            // --- Start Excel Process ---
            UpdateStatusMain("Opening Excel...");
            // Run Process.Start on background thread to avoid potential UI block
            excelProcess = await Task.Run(() =>
            {
                try
                {
                    // UseShellExecute = true uses the default application associated with .xlsx files
                    return Process.Start(new ProcessStartInfo(filePath) { UseShellExecute = true });
                }
                catch (Exception ex)
                {
                    Logger.LogError($"Failed to start Excel process for '{filePath}': {ex.Message}");
                    return null; // Return null if starting fails
                }
            }, token);

            // Check if process start failed
            if (excelProcess == null)
            {
                throw new Exception($"Failed to open the Excel file: {filePath}. Ensure Excel is installed and the file is accessible.");
            }

            // --- Wait for User to Close Excel ---
            UpdateStatusMain("Excel opened. Waiting for you to Refresh All, Save, and Close...");
            Logger.LogInfo($"Waiting for Excel process (ID: {excelProcess.Id}) to exit...");

            // Asynchronously wait for the specific Excel process to exit
            await excelProcess.WaitForExitAsync(token);

            token.ThrowIfCancellationRequested(); // Check immediately after exit or cancellation

            Logger.LogInfo("Excel process has exited.");
            UpdateStatusMain("Excel closed.");

            // --- Confirm Continuation ---
            // Ask the user if they want to proceed (e.g., with emailing)
            DialogResult sendResult = FlexibleMessageBox.Show( // Use FlexibleMessageBox
                "Excel has been closed.\n\nDo you want to proceed with sending the email now?",
                "Confirm Email Send",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);

            userConfirmedProceed = (sendResult == DialogResult.Yes);
            return userConfirmedProceed; // Return user's choice
        }
        catch (OperationCanceledException)
        {
            Logger.LogWarning("Manual Excel refresh step cancelled.");
            UpdateStatusMain("Manual refresh cancelled.");
            return false; // Indicate cancellation
        }
        catch (Exception ex) // Catch errors during process start or waiting
        {
            Logger.LogError($"Error during manual Excel handling: {ex}");
            FlexibleMessageBox.Show($"An error occurred while managing the Excel refresh process:\n\n{ex.Message}", "Excel Interaction Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            UpdateStatusMain("Error during manual refresh.");
            return false; // Indicate error
        }
        finally
        {
            // Ensure the process handle is released
            excelProcess?.Dispose();
        }
    }

    /// <summary>
    /// Attempts to find and terminate all running Excel processes.
    /// This is a forceful approach (Kill) and should be used with caution.
    /// Synchronous method, intended to be run via Task.Run if needed off the UI thread.
    /// </summary>
    private static void CloseExcelProcesses()
    {
        Process[] processes;
        try
        {
            // Get all processes named "EXCEL"
            processes = Process.GetProcessesByName("EXCEL");
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error getting Excel processes: {ex.Message}");
            return; // Cannot proceed if getting processes fails
        }

        if (processes.Length == 0)
        {
            Logger.LogInfo("No running Excel processes found to close.");
            return;
        }

        Logger.LogInfo($"Found {processes.Length} Excel processes. Attempting to terminate...");
        foreach (var process in processes)
        {
            using (process) // Ensure process object is disposed
            {
                try
                {
                    // Check if the process is still running before trying to kill
                    if (!process.HasExited)
                    {
                        Logger.LogInfo($"Attempting to terminate Excel process ID: {process.Id} (MainWindowTitle: '{process.MainWindowTitle}')");
                        // Forcefully terminate the process and its child processes (if any)
                        process.Kill(true);
                        // Wait briefly for termination to complete
                        process.WaitForExit(5000); // Wait up to 5 seconds
                        if (process.HasExited)
                            Logger.LogInfo($"Successfully terminated Excel process ID: {process.Id}");
                        else
                            Logger.LogWarning($"Excel process ID: {process.Id} did not terminate after Kill.");
                    }
                }
                catch (InvalidOperationException ex) when (ex.Message.Contains("Process has exited"))
                {
                    // Ignore error if process already exited between check and kill attempt
                    Logger.LogInfo($"Excel process ID: {process.Id} already exited.");
                }
                catch (Exception ex)
                {
                    // Log errors during termination (e.g., access denied)
                    Logger.LogError($"Error terminating Excel process ID {process.Id}: {ex.Message}");
                }
            }
        }
        Logger.LogInfo("Finished attempting to terminate Excel processes.");
    }


    #endregion

    #region Wrapper Process Handling (Async Check/Launch)

    /// <summary>
    /// Asynchronously ensures the Crystal Report Wrapper process is running, launching it if necessary.
    /// </summary>
    /// <param name="cancellationToken">Token to allow cancellation.</param>
    /// <returns>True if the wrapper is running or was successfully launched, false otherwise.</returns>
    private async Task<bool> EnsureWrapperIsRunningAsync(CancellationToken cancellationToken = default)
    {
        // Check if already running (synchronous check is usually acceptable here)
        if (IsWrapperRunning())
        {
            Logger.LogInfo($"Wrapper process '{WrapperProcessName}' is already running.");
            return true;
        }

        // If not running, attempt to launch
        Logger.LogWarning($"Wrapper process '{WrapperProcessName}' not found. Attempting to launch...");
        UpdateStatusMain("Starting report service...");

        try
        {
            // Launch the process (run synchronous LaunchWrapper on background thread)
            await Task.Run(() => LaunchWrapper(), cancellationToken);

            // Wait briefly for the process to initialize its named pipe server
            await Task.Delay(3000, cancellationToken); // 3 seconds grace period

            // Check again if it's running after the launch attempt
            if (IsWrapperRunning())
            {
                Logger.LogInfo($"Wrapper process '{WrapperProcessName}' appears to be running after launch.");
                UpdateStatusMain("Report service started.");
                return true;
            }
            else // Launch attempt failed or process terminated quickly
            {
                Logger.LogError($"Wrapper process '{WrapperProcessName}' did not start successfully or terminated unexpectedly after launch attempt.");
                UpdateStatusMain("Error: Failed to start report service.");
                return false;
            }
        }
        catch (OperationCanceledException)
        {
            Logger.LogWarning("Operation cancelled during wrapper launch check.");
            UpdateStatusMain("Operation cancelled.");
            return false;
        }
        catch (Exception launchEx) // Catch errors during LaunchWrapper or Task.Run
        {
            Logger.LogError($"Failed to launch the Crystal Report Wrapper ('{WrapperExePath}'): {launchEx.Message}", launchEx);
            FlexibleMessageBox.Show($"Could not start the required report service ({WrapperProcessName}).\n" +
                            $"Please check the path in configuration ('{WrapperExePath}') and ensure the application exists and has permissions to run.\n\n" +
                            $"Error: {launchEx.Message}",
                            "Wrapper Launch Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            UpdateStatusMain("Error: Failed to start report service.");
            // Disable report creation button if wrapper fails to launch
            SafeControlUpdate(createReportButton, () => { createReportButton.Enabled = false; }); // Use correct name
            return false;
        }
    }

    /// <summary>
    /// Checks if the wrapper process (identified by WrapperProcessName) is currently running. Synchronous.
    /// </summary>
    /// <returns>True if at least one process with the name is running, false otherwise.</returns>
    private bool IsWrapperRunning()
    {
        string processName = WrapperProcessName;
        if (string.IsNullOrEmpty(processName))
        {
            Logger.LogError("Wrapper process name is not configured. Cannot check if running.");
            return false;
        }
        try
        {
            // Get processes by name (can be slightly slow, consider Task.Run if UI lags)
            Process[] processes = Process.GetProcessesByName(processName);
            bool isRunning = processes.Length > 0;
            // Dispose the process handles returned by GetProcessesByName
            foreach (var p in processes) p.Dispose();
            return isRunning;
        }
        catch (Exception ex) // Catch errors getting process list (e.g., permissions)
        {
            Logger.LogError($"Error checking for wrapper process '{processName}': {ex.Message}");
            return false; // Assume not running if check fails
        }
    }

    /// <summary>
    /// Launches the wrapper executable specified by WrapperExePath. Synchronous.
    /// </summary>
    /// <exception cref="FileNotFoundException">Thrown if the executable path is invalid or file not found.</exception>
    /// <exception cref="Exception">Thrown if Process.Start fails for other reasons (permissions, etc.).</exception>
    private void LaunchWrapper()
    {
        string exePath = WrapperExePath;
        if (!File.Exists(exePath))
        {
            throw new FileNotFoundException($"Wrapper executable not found at the configured path: {exePath}");
        }

        try
        {
            Logger.LogInfo($"Launching wrapper: {exePath}");
            // Configure start info: UseShellExecute is generally preferred for launching external EXEs.
            // Set WorkingDirectory in case the wrapper depends on files in its own folder.
            var startInfo = new ProcessStartInfo(exePath)
            {
                WorkingDirectory = Path.GetDirectoryName(exePath) ?? string.Empty,
                UseShellExecute = true
            };
            // Start the process (fire-and-forget, we don't wait for exit here)
            Process.Start(startInfo);
            Logger.LogInfo($"Wrapper launch command initiated for '{exePath}'.");
        }
        catch (Exception ex) // Catch errors during Process.Start
        {
            Logger.LogError($"Failed to start wrapper process '{exePath}': {ex.Message}", ex);
            // Re-throw wrapped exception for better context
            throw new Exception($"Failed to start the wrapper process '{exePath}'. Check permissions and path.", ex);
        }
    }

    /// <summary>
    /// Attempts to find and terminate the wrapper process on application exit. Synchronous.
    /// Uses Kill for forceful termination.
    /// </summary>
    private void TerminateWrapperProcess()
    {
        string processName = WrapperProcessName;
        if (string.IsNullOrEmpty(processName)) return; // Nothing to terminate if name is missing

        Logger.LogInfo($"Attempting to terminate wrapper process '{processName}' on application exit...");
        Process[] processes;
        try
        {
            // Find running processes by name
            processes = Process.GetProcessesByName(processName);
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error finding wrapper processes '{processName}' to terminate: {ex.Message}");
            return;
        }

        if (processes.Length == 0)
        {
            Logger.LogInfo("Wrapper process not found, likely already closed.");
            return;
        }

        // Iterate through found processes and attempt termination
        foreach (var process in processes)
        {
            using (process) // Ensure disposal of process object
            {
                try
                {
                    if (!process.HasExited) // Check if it's still running
                    {
                        Logger.LogInfo($"Terminating wrapper process ID: {process.Id}");
                        process.Kill(true); // Force kill process and descendants
                        process.WaitForExit(2000); // Wait briefly for termination
                        if (process.HasExited)
                            Logger.LogInfo($"Wrapper process {process.Id} terminated.");
                        else
                            Logger.LogWarning($"Wrapper process {process.Id} did not terminate after Kill.");
                    }
                }
                catch (Exception ex) // Catch errors during termination (permissions, process already exited)
                {
                    Logger.LogWarning($"Error terminating wrapper process ID {process.Id}: {ex.Message}");
                }
            }
        }
        Logger.LogInfo("Finished attempting to terminate wrapper processes.");
    }

    #endregion

    #region Email Handling (Async)

    /// <summary>
    /// Asynchronously prepares email details (recipients, subject, body) and sends the email
    /// with the specified report file attached using EmailUtility. Handles UI updates.
    /// </summary>
    /// <param name="attachmentPath">The full path to the report file to attach.</param>
    /// <param name="progress">Reporter for updating status messages during sending.</param>
    /// <param name="cancellationToken">Token to allow cancellation.</param>
    /// <returns>A Task representing the asynchronous operation.</returns>
    private async Task SendCompletionEmailAsync(string attachmentPath, IProgress<string> progress, CancellationToken cancellationToken)
    {
        Logger.LogInfo($"Preparing completion email with attachment: {attachmentPath}");
        progress?.Report("Preparing email..."); // Use progress reporter

        if (!File.Exists(attachmentPath))
        {
            Logger.LogError($"Attachment file not found: {attachmentPath}");
            throw new FileNotFoundException("The attachment file for the email was not found.", attachmentPath);
        }

        try
        {
            // --- Determine Recipients ---
            var (toAddresses, ccAddresses) = GetEmailRecipients();
            if (toAddresses.Count == 0 && ccAddresses.Count == 0)
            {
                Logger.LogError("No valid email recipients configured or found. Cannot send email.");
                throw new InvalidOperationException("No valid email recipients configured or found. Cannot send email.");
            }

            // --- Determine Subject and Body ---
            // Pass the actual end date used for the report
            var (subject, body) = GetEmailSubjectAndBody(endDatePicker.Value);

            // --- Send Email via Utility ---
            bool success = await _emailUtility.SendEmailAsync(
                toAddresses, ccAddresses, subject, body, attachmentPath, progress, cancellationToken);

            // --- Handle Result ---
            if (success)
            {
                Logger.LogInfo("Email sent successfully.");
                UpdateStatusMain("Email sent successfully."); // Update main status
                // Let ResetUIOnError handle the delay and reset to "Ready"
                SetUICompleted(); // Reset UI for next manual run
            }
            else
            {
                if (!cancellationToken.IsCancellationRequested)
                {
                    Logger.LogError("Email sending failed (SendEmailAsync returned false). Check previous logs.");
                    throw new Exception("Email sending failed. Check logs for details.");
                }
                // If cancelled, the exception will be caught below
            }
        }
        catch (OperationCanceledException)
        {
            Logger.LogWarning("Email sending was cancelled.");
            // UpdateStatusMain("Email sending cancelled."); // ResetUIOnError handles status update
            ResetUIOnError("Cancelled"); // Reset UI after cancellation
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error sending completion email: {ex}");
            FlexibleMessageBox.Show($"Failed to send the completion email:\n\n{ex.Message}", "Email Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            // UpdateStatusMain($"Email Error: {ex.Message}"); // ResetUIOnError handles status update
            ResetUIOnError("Email Failed"); // Reset UI after error
        }
    }

    /// <summary>
    /// Determines the To and CC email recipients based on the selected report type,
    /// the state of the 'Send to Femi Only' checkbox, and the build configuration (Debug/Release).
    /// Includes a special override rule for Daily reports in Release mode.
    /// </summary>
    /// <returns>A tuple containing a List of To addresses and a List of CC addresses.</returns>
    private (List<string> To, List<string> Cc) GetEmailRecipients()
    {
        List<string> toAddresses = []; // Initialize empty lists
        List<string> ccAddresses = [];
        bool sendToFemiOnly = sendToFemiOnlyCheckBox.Checked;
        int currentReportType = reportTypeComboBox.SelectedIndex;

        // --- Special Rule: Daily Report in RELEASE Mode ---
        // If the report type is Daily AND the application is NOT running in Debug mode...
        if (currentReportType == DailyReportIndex && !IsDebug)
        {
            Logger.LogInfo("RELEASE Build & Daily Report: Applying special rule - Sending only to PaulS & IT.");
            // Set recipient directly to Paul S & IT.
            toAddresses.Add("pauls@harlowsolutions.co.uk");
            ccAddresses.Add("itdept@harlowsolutions.co.uk");
            // ccAddresses.Clear(); // Keep IT in CC based on original logic

            // Log the specific recipients for this rule and return immediately
            Logger.LogDebug($"To Addresses (Daily Rule): {string.Join("; ", toAddresses)}");
            Logger.LogDebug($"CC Addresses (Daily Rule): {string.Join("; ", ccAddresses)}");
            return (toAddresses, ccAddresses);
        }

        // --- Default Logic (Applies to DEBUG Mode OR Non-Daily Reports in RELEASE Mode) ---
#if DEBUG
        // --- DEBUG Build Recipients ---
        // Always use debug recipients defined in configuration for DEBUG builds
        Logger.LogInfo("DEBUG Build: Using debug email recipients.");
        // Get debug TO address from config, fallback to default
        toAddresses.Add(_configuration["settings:DebugEmails:To"] ?? "chrisp@harlowsolutions.co.uk");
        // Determine debug CC based on the "Femi Only" checkbox state (for testing the checkbox logic)
        string debugCC = sendToFemiOnly
            ? (_configuration["settings:DebugEmails:CC2"] ?? "chrisp@harlowsolutions.co.uk") // Use CC2 if checkbox is checked
            : (_configuration["settings:DebugEmails:CC1"] ?? "jamier@harlowsolutions.co.uk"); // Use CC1 if checkbox is unchecked
        // Add the determined CC address if it's not empty
        if (!string.IsNullOrWhiteSpace(debugCC)) ccAddresses.Add(debugCC);

#else
        // --- RELEASE Build Recipients (for non-Daily reports) ---
        // This block only executes in RELEASE builds for Weekly, Monthly, Quarterly, Annual reports
        Logger.LogInfo($"RELEASE Build (Non-Daily): SendToFemiOnly = {sendToFemiOnly}");
        if (sendToFemiOnly) // Checkbox IS checked
        {
            // Send only to Femi's address (from config or default)
            toAddresses.Add(_configuration["settings:ProductionEmails:FemiTo"] ?? "femi@harlowsolutions.co.uk");
            // Get the specific CC list for Femi (from config or default)
            ccAddresses = GetStringListFromConfig("settings:ProductionEmails:FemiCC")
                            ?? ["ITdept@harlowsolutions.co.uk"]; // Default CC list when sending to Femi
            Logger.LogInfo("Sending to Femi (and FemiCC list).");
        }
        else // Checkbox is NOT checked
        {
            // Send to the main team list (from config or default)
            toAddresses = GetStringListFromConfig("settings:ProductionEmails:TeamTo")
                            ?? ["andrewp@harlowsolutions.co.uk", "kirstym@harlowsolutions.co.uk", "stuartm@harlowsolutions.co.uk"]; // Default Team TO list
            // Get the main team CC list (from config or default)
            ccAddresses = GetStringListFromConfig("settings:ProductionEmails:TeamCC")
                            ?? ["emmanuel@harlowsolutions.co.uk", "femi@harlowsolutions.co.uk", "jackh@harlowsolutions.co.uk", "pauls@harlowsolutions.co.uk", "ITdept@harlowsolutions.co.uk", "gordonb@harlowsolutions.co.uk"]; // Default Team CC list
            Logger.LogInfo("Sending to Team list.");
        }
#endif

        // Log the final recipient lists determined by the default logic path
        Logger.LogDebug($"To Addresses (Default Logic): {string.Join("; ", toAddresses)}");
        Logger.LogDebug($"CC Addresses (Default Logic): {string.Join("; ", ccAddresses)}");

        return (toAddresses, ccAddresses);
    }


    /// <summary>
    /// Reads a configuration value by key and attempts to split it into a list of strings
    /// using common delimiters (comma, semicolon, space). Returns null if the key is not found or value is empty.
    /// </summary>
    /// <param name="key">The configuration key (e.g., "settings:ProductionEmails:TeamCC").</param>
    /// <returns>A List of strings, or null if the configuration value is missing or empty.</returns>
    private List<string>? GetStringListFromConfig(string key)
    {
        string? configValue = _configuration[key]; // Read value from configuration
        if (string.IsNullOrWhiteSpace(configValue))
        {
            return null; // Return null if key doesn't exist or value is empty/whitespace
        }
        // Split the string by delimiters, remove empty entries, trim whitespace from each entry
        return [.. configValue.Split([',', ';', ' '], StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)];
    }

    /// <summary>
    /// Generates the email subject and body text based on the selected report type,
    /// date range, and build configuration (for greeting). Includes special greeting for Daily/Release.
    /// </summary>
    /// <param name="reportEndDate">The end date used for the report generation (from endDatePicker).</param>
    /// <returns>A tuple containing the email Subject string and the email Body string.</returns>
    private (string Subject, string Body) GetEmailSubjectAndBody(DateTime reportEndDate)
    {
        string reportTypeName = "Estimate Success Rate"; // Base name for the report
        int currentReportType = reportTypeComboBox.SelectedIndex;
        bool isFemiOnlyChecked = sendToFemiOnlyCheckBox.Checked;

        // Determine greeting based on Debug mode or Femi checkbox state
        string greeting = IsDebug ? "Hi Debug," : (isFemiOnlyChecked ? "Hi Femi," : "Hi All,");

        // --- Special Greeting Override for Daily Release Email ---
        if (currentReportType == DailyReportIndex && !IsDebug)
        {
            greeting = "Hi Paul,"; // Override greeting specifically for Paul
        }

        string dateRangeInfo = string.Empty; // Placeholder for date description
        string subjectPrefix = string.Empty; // Placeholder for subject prefix (e.g., "Daily", "Weekly")
        DateTime fromDate = startDatePicker.Value; // Use start date from picker for context
        DateTime toDate = reportEndDate; // Use the provided end date

        // Determine subject prefix and date range description based on report type
        switch (currentReportType)
        {
            case DailyReportIndex:
                subjectPrefix = $"Daily {reportTypeName}";
                dateRangeInfo = $"for {toDate:dd MMM yyyy}"; // Use the actual report date (previous workday)
                break;
            case WeeklyReportIndex:
                subjectPrefix = $"Weekly {reportTypeName}";
                dateRangeInfo = $"for the period ending {toDate:dd MMM yyyy}";
                break;
            case MonthlyReportIndex:
                subjectPrefix = $"Monthly {reportTypeName}";
                // Monthly range calculation uses 'today', so fromDate should reflect the start of that month
                dateRangeInfo = $"for {fromDate:MMMM yyyy}";
                break;
            case QuarterlyReportIndex:
                subjectPrefix = $"Quarterly {reportTypeName}";
                // Quarterly range calculation uses 'today', fromDate reflects start of previous quarter
                dateRangeInfo = $"for {GetQuarterString(fromDate)} {fromDate.Year}"; // Format: Q2 2025
                break;
            case AnnualReportIndex:
                subjectPrefix = $"Annual {reportTypeName}";
                dateRangeInfo = $"for {fromDate.Year}"; // Format: 2024
                break;
            default: // Fallback for unexpected index
                subjectPrefix = reportTypeName;
                dateRangeInfo = $"from {fromDate:d} to {toDate:d}"; // Generic date range
                break;
        }

        // Construct final subject and body
        string subject = $"AUTOMATED: {subjectPrefix} Report ({toDate:yyyy-MM-dd})";
        string body = $"{greeting}\n\nPlease find attached the {subjectPrefix} report {dateRangeInfo}.\n\nThis report includes quotes data for review.\n\nThank you,\nAutomation Service";

        return (subject, body);
    }

    #endregion

    #region Dark Mode Theme Logic

    /// <summary>
    /// Applies the selected theme (Dark or Light) to the form and its relevant controls.
    /// </summary>
    /// <param name="isDarkMode">True to apply dark mode, false to apply light mode.</param>
    private void ApplyTheme(bool isDarkMode)
    {
        // Determine colors based on the mode
        Color backColor = isDarkMode ? _darkModeBackColor : _lightModeBackColor;
        Color foreColor = isDarkMode ? _darkModeForeColor : _lightModeForeColor;
        Color buttonBackColor = isDarkMode ? _darkModeButtonBackColor : _lightModeButtonBackColor;
        Color buttonForeColor = foreColor; // Buttons usually use the standard foreground color
        Color textBoxBackColor = isDarkMode ? _darkModeTextBoxBackColor : _lightModeTextBoxBackColor;
        Color textBoxForeColor = foreColor; // Inputs use standard foreground color
        Color menuBackColor = isDarkMode ? _darkModeMenuBackColor : _lightModeMenuBackColor;
        Color menuForeColor = isDarkMode ? _darkModeMenuForeColor : _lightModeMenuForeColor;
        Color statusStripBackColor = isDarkMode ? _darkModeBackColor : _lightModeBackColor; // Match form background
        Color statusStripForeColor = foreColor;
        Color checkBoxBackColor = isDarkMode ? _darkModeCheckBoxBackColor : Color.Transparent;

        // Apply to Form itself
        BackColor = backColor;
        ForeColor = foreColor; // Sets default text color for controls inheriting from form

        // Apply colors to child controls recursively/selectively
        UpdateControlColors(Controls, backColor, foreColor, buttonBackColor, buttonForeColor, textBoxBackColor, textBoxForeColor, checkBoxBackColor);

        // Apply specific styling for MenuStrip and StatusStrip
        menuStrip1.BackColor = menuBackColor;
        menuStrip1.ForeColor = menuForeColor;
        // Apply to menu items recursively
        UpdateMenuItemsTheme(menuStrip1.Items, menuBackColor, menuForeColor);

        mainStatusStrip.BackColor = statusStripBackColor;
        mainStatusStrip.ForeColor = statusStripForeColor;
        // Update the status label colors within the strip
        if (mainStatusStrip.Items.Count > 0 && mainStatusStrip.Items[0] is ToolStripStatusLabel generalStatusLabel)
        {
            generalStatusLabel.ForeColor = statusStripForeColor;
        }
        if (mainStatusStrip.Items.Count > 1 && mainStatusStrip.Items[1] is ToolStripStatusLabel autoRunLabel)
        {
            // AutoRun label color is handled by UpdateAutoRunUI based on state
            // We just set the default text color here if needed.
            // autoRunLabel.ForeColor = statusStripForeColor; // Let UpdateAutoRunUI handle this
        }


        // Apply theme to Auto Run label (as it might have specific color)
        UpdateAutoRunUI(dailyCheckTimer.Enabled); // Re-apply UI state which includes color logic

        Logger.LogInfo($"Theme applied: {(isDarkMode ? "Dark Mode" : "Light Mode")}");
    }

    /// <summary>
    /// Recursively updates the BackColor and ForeColor of menu items.
    /// </summary>
    private static void UpdateMenuItemsTheme(ToolStripItemCollection items, Color backColor, Color foreColor)
    {
        foreach (ToolStripItem item in items)
        {
            item.BackColor = backColor;
            item.ForeColor = foreColor;
            if (item is ToolStripMenuItem menuItem && menuItem.HasDropDownItems)
            {
                // Apply to sub-menu items
                UpdateMenuItemsTheme(menuItem.DropDownItems, backColor, foreColor);
            }
        }
    }


    /// <summary>
    /// Recursively updates the BackColor and ForeColor of controls within a collection,
    /// applying specific styles for known control types. Skips AutoRun button background.
    /// </summary>
    /// <param name="controls">The collection of controls to update.</param>
    /// <param name="backColor">The general background color.</param>
    /// <param name="foreColor">The general foreground (text) color.</param>
    /// <param name="buttonBackColor">Specific background color for *most* buttons.</param>
    /// <param name="buttonForeColor">Specific foreground color for buttons.</param>
    /// <param name="textBoxBackColor">Specific background color for text/input boxes.</param>
    /// <param name="textBoxForeColor">Specific foreground color for text/input boxes.</param>
    /// <param name="checkBoxBackColor">Specific background color for checkboxes in the current theme.</param> // <<< ADDED Parameter
    private static void UpdateControlColors(
        Control.ControlCollection controls,
        Color backColor, Color foreColor,
        Color buttonBackColor, Color buttonForeColor,
        Color textBoxBackColor, Color textBoxForeColor,
        Color checkBoxBackColor) // <<< ADDED Parameter
    {
        // Iterate through each control in the provided collection
        foreach (Control control in controls)
        {
            // --- Handle specific control types for better theme application ---

            if (control is Button button)
            {
                // <<< Skip setting background color for the AutoRun button >>>
                if (button.Name == "toggleAutoRunButton")
                {
                    button.ForeColor = buttonForeColor; // Set text color only
                    // Background color is handled by UpdateAutoRunUI
                }
                else // Apply theme colors to other buttons
                {
                    button.BackColor = buttonBackColor;
                    button.ForeColor = buttonForeColor;
                }
                // Consider setting FlatStyle=Flat and FlatAppearance in Designer for best results
            }
            else if (control is TextBox || control is RichTextBox)
            {
                control.BackColor = textBoxBackColor;
                control.ForeColor = textBoxForeColor;
            }
            else if (control is DateTimePicker dtp)
            {
                // DateTimePicker styling is limited.
                dtp.BackColor = textBoxBackColor;
                dtp.ForeColor = textBoxForeColor;
            }
            else if (control is ComboBox comboBox)
            {
                // ComboBox styling is limited, especially the dropdown list.
                comboBox.BackColor = textBoxBackColor;
                comboBox.ForeColor = textBoxForeColor;
                // Set FlatStyle=Flat in Designer for consistency if desired.
            }
            else if (control is CheckBox checkbox)
            {
                // *** UPDATED: Apply specific CheckBox background color ***
                checkbox.BackColor = checkBoxBackColor; // Use the theme-specific color
                checkbox.ForeColor = foreColor;
            }
            else if (control is Label label)
            {
                // Make most labels transparent.
                if (label.Name == "emailRecipientLabel") // Use correct name for Paul label
                {
                    // Keep specific background for emailRecipientLabel
                    label.BackColor = backColor; // Match form background
                    label.ForeColor = foreColor;
                }
                else
                {
                    label.BackColor = Color.Transparent;
                    label.ForeColor = foreColor;
                }
            }
            else if (control is GroupBox groupBox)
            {
                // Style the GroupBox text color. Background is usually handled by container.
                groupBox.ForeColor = foreColor;
                // Recursively apply themes to controls *inside* the GroupBox
                UpdateControlColors(groupBox.Controls, backColor, foreColor, buttonBackColor, buttonForeColor, textBoxBackColor, textBoxForeColor, checkBoxBackColor); // Pass checkbox color down
            }
            else if (control is Panel panel) // Apply to Panels too
            {
                // Panels often act as containers, match the main background.
                panel.BackColor = backColor;
                // Recursively apply themes to controls *inside* the Panel
                UpdateControlColors(panel.Controls, backColor, foreColor, buttonBackColor, buttonForeColor, textBoxBackColor, textBoxForeColor, checkBoxBackColor); // Pass checkbox color down
            }
            else if (control is StatusStrip || control is ToolStrip || control is MenuStrip) // Skip strips
            {
                // These are handled separately in ApplyTheme or require custom renderers.
                continue;
            }
            else // Default for other/unknown controls
            {
                // Apply general back/fore colors. Might need adjustment for custom controls.
                try
                {
                    control.BackColor = backColor;
                    control.ForeColor = foreColor;
                }
                catch (Exception ex)
                {
                    // Log if setting color fails for an unexpected control type
                    Logger.LogWarning($"Could not set theme colors for control '{control.Name}' of type {control.GetType().Name}: {ex.Message}");
                }
            }
        }
    }

    #endregion

    #region Auto Run Logic

    /// <summary>
    /// Updates the UI elements related to the auto-run feature (button text/color, status label text/color).
    /// Preserves final status messages like "Completed" or "FAILED" for the current day.
    /// </summary>
    /// <param name="enable">True if auto-run is enabled, false otherwise.</param>
    private void UpdateAutoRunUI(bool enable)
    {
        SafeControlUpdate(mainStatusStrip, () =>
        {
            if (autoRunStatusLabel == null || autoRunStatusLabel.IsDisposed || toggleAutoRunButton == null || toggleAutoRunButton.IsDisposed) return;

            string currentStatusText = autoRunStatusLabel.Text ?? string.Empty;
            // Check if the current status is a final one *for the current date*
            bool isFinalStatusForToday = (_autoRunStatusDate == DateTime.Today) &&
                                         (currentStatusText.Contains("Completed") || currentStatusText.Contains("FAILED") || currentStatusText.Contains("Done for"));

            if (enable)
            {
                toggleAutoRunButton.Text = "Disable Daily Auto Run @ 8 AM";
                toggleAutoRunButton.BackColor = _autoRunEnabledColor;
                // Only update text if not showing a final status for today
                if (!isFinalStatusForToday)
                {
                    autoRunStatusLabel.Text = "Auto Run: Enabled";
                }
                // Always set color to green if enabled, regardless of text
                autoRunStatusLabel.ForeColor = Color.Green;
            }
            else // Timer is disabled
            {
                toggleAutoRunButton.Text = "Enable Daily Auto Run @ 8 AM";
                toggleAutoRunButton.BackColor = _autoRunDisabledColor;
                // Only update text if not showing a final status for today
                if (!isFinalStatusForToday)
                {
                    autoRunStatusLabel.Text = "Auto Run: Disabled";
                }
                // Use theme-appropriate color for disabled/final status text
                autoRunStatusLabel.ForeColor = darkModeToolStripMenuItem.Checked ? _darkModeForeColor : _lightModeForeColor;
            }

            // Ensure button text color contrasts with background
            toggleAutoRunButton.ForeColor = (enable ? _autoRunEnabledColor : _autoRunDisabledColor).GetBrightness() > 0.5f
                                            ? Color.Black
                                            : Color.White;
        });
    }


    /// <summary>
    /// Executes the automated daily report generation, processing, and emailing sequence.
    /// This method is designed to be called by the timer tick event.
    /// **It now uses the previous workday for the report dates.**
    /// </summary>
    /// <returns>A Task representing the asynchronous operation. The task result is true if all steps completed successfully, false otherwise.</returns>
    private async Task<bool> RunAutomatedDailyReportAsync()
    {
        Logger.LogInfo("Auto Run: Starting automated daily report process...");
        string? generatedRawPath = null;
        string? finalAnalysisPath = null;
        bool overallSuccess = false;
        DateTime runStartTime = DateTime.Now; // Capture start time for final status
        DateTime reportDate = GetPreviousWorkday(DateTime.Today); // *** Get the date for the report ***

        // Use a CancellationTokenSource specific to this run
        using var cts = new CancellationTokenSource(TimeSpan.FromMinutes(20)); // Generous timeout
        var token = cts.Token;

        // Progress reporters for status updates
        IProgress<string> progress = new Progress<string>(status => UpdateStatusMain($"Auto Run: {status}"));
        IProgress<ProgressReport> excelProgress = new Progress<ProgressReport>(report => UpdateStatusMain($"Auto Run: {report.Message}"));


        try
        {
            // --- Step 1: Generate Raw Report (like Button 1) ---
            progress.Report("Ensuring report service...");
            if (!await EnsureWrapperIsRunningAsync(token))
            { throw new InvalidOperationException($"Auto Run Error: Failed to start or connect to the report service ({WrapperProcessName})."); }

            progress.Report("Preparing request...");
            // *** Use the calculated reportDate for the output path ***
            string dailyOutputPath = GetAutomatedReportOutputPath(DailyReportIndex, reportDate);

            var request = new ReportRequest
            {
                CrystalReportLocation = CrystalReportLocation,
                ReportOutputLocation = dailyOutputPath,
                // *** Use the calculated reportDate for the request parameters ***
                ReportDateFrom = reportDate,
                ReportDateTo = reportDate
            };

            progress.Report("Requesting report...");
            ReportResponse? response = await SendRequestReceiveResponseAsync(request, token);

            if (response?.Success == true && !string.IsNullOrEmpty(response.OutputPath) && File.Exists(response.OutputPath))
            {
                generatedRawPath = response.OutputPath;
                Logger.LogInfo($"Auto Run: Raw report generated for {reportDate:yyyy-MM-dd}: {generatedRawPath}");
                progress.Report("Raw report created.");
            }
            else
            {
                string errorMessage = response?.ErrorMessage ?? "Unknown error from report service.";
                if (response?.Success == true && (string.IsNullOrEmpty(response.OutputPath) || !File.Exists(response.OutputPath)))
                { errorMessage = $"Auto Run Error: Report service success, but output file invalid/missing ('{response?.OutputPath ?? "NULL"}')."; }
                throw new Exception($"Auto Run Error: Report generation failed: {errorMessage}");
            }

            // --- Step 2: Process Report (like Button 2, but automated) ---
            progress.Report("Processing report...");
            string templatePath = GetAutomatedTemplatePath(DailyReportIndex); // Get daily/weekly template
            string baseSaveLocation = ExcelFinalSaveLocation; // Base dir for final reports
            string currentFY = ExcelCopyData.GetCurrentFinancialYear(true); // Get current FY

            // Validate paths
            if (string.IsNullOrEmpty(templatePath) || !File.Exists(templatePath))
            { throw new FileNotFoundException($"Auto Run Error: Required template not found.", templatePath); }
            if (string.IsNullOrEmpty(generatedRawPath) || !File.Exists(generatedRawPath))
            { throw new FileNotFoundException("Auto Run Error: Raw report to process not found.", generatedRawPath); }
            if (string.IsNullOrEmpty(baseSaveLocation))
            { throw new InvalidOperationException("Auto Run Error: Base save location not configured."); }


            // Delete existing final file for the report date if it exists
            // *** Call GetExpectedFinalFilePath WITH the date argument ***
            string? expectedFinalPath = ExcelCopyData.GetExpectedFinalFilePath(DailyReportIndex, baseSaveLocation, reportDate);
            if (expectedFinalPath != null && File.Exists(expectedFinalPath))
            {
                try { File.Delete(expectedFinalPath); Logger.LogInfo($"Auto Run: Deleted existing file: {expectedFinalPath}"); }
                catch (Exception delEx) { Logger.LogWarning($"Auto Run: Failed to delete existing file '{expectedFinalPath}': {delEx.Message}"); /* Continue anyway */ }
            }


            // Call processing function
            // *** Call ProcessExcelReportAsync WITH the date argument ***
            finalAnalysisPath = await ExcelCopyData.ProcessExcelReportAsync(
                currentFY, DailyReportIndex,
                generatedRawPath, "Sheet1", baseSaveLocation, templatePath, "DATA",
                1, 1, excelProgress, reportDate, token // Pass reportDate
            );

            if (string.IsNullOrEmpty(finalAnalysisPath) || !File.Exists(finalAnalysisPath))
            { throw new Exception("Auto Run Error: Excel processing failed. Check logs."); }

            Logger.LogInfo($"Auto Run: Report processed for {reportDate:yyyy-MM-dd}: {finalAnalysisPath}");
            progress.Report("Report processed."); // Report string status

            // --- Step 3: Email Report ---
            progress.Report("Sending email..."); // Report string status
            List<string> mailTo;
            List<string> mailCc;

            // Determine recipients based on build mode (Daily Release rule applies)
            if (IsDebug)
            {
                // Use debug recipients for testing
                mailTo = GetStringListFromConfig("settings:DebugEmails:To") ?? ["chrisp@harlowsolutions.co.uk"];
                mailCc = GetStringListFromConfig("settings:DebugEmails:CC1") ?? ["itdept@harlowsolutions.co.uk"];
                Logger.LogInfo("Auto Run (DEBUG): Sending email to Debug recipients.");
            }
            else
            {
                // Use production recipients for PaulS & IT CC
                mailTo = ["pauls@harlowsolutions.co.uk"];
                mailCc = ["itdept@harlowsolutions.co.uk"];
                Logger.LogInfo("Auto Run (RELEASE): Sending email to PaulS and IT Dept CC.");
            }


            // Get subject/body (using Daily type and the actual reportDate)
            var (subject, body) = GetEmailSubjectAndBodyForAutoRun(DailyReportIndex, reportDate);

            // Send email - Pass the STRING progress reporter
            bool emailSuccess = await _emailUtility.SendEmailAsync(
                mailTo, mailCc, subject, body, finalAnalysisPath, progress, token); // Pass IProgress<string>

            if (!emailSuccess)
            { throw new Exception("Auto Run Error: Email sending failed. Check EmailUtility logs."); }

            Logger.LogInfo("Auto Run: Email sent successfully.");
            progress.Report("Email sent."); // Report string status
            overallSuccess = true; // Mark overall success
        }
        catch (OperationCanceledException)
        {
            Logger.LogWarning("Auto Run: Operation cancelled.");
            progress.Report("Operation cancelled."); // Report string status
            overallSuccess = false;
        }
        catch (Exception ex)
        {
            Logger.LogError($"Auto Run: Error during automated process: {ex}");
            progress.Report($"ERROR: {ex.Message}"); // Report string status
            overallSuccess = false;
            // Consider sending an error notification email to an admin here
        }
        // NOTE: The 'finally' block is now part of the dailyCheckTimer_Tick method
        // to ensure controls are re-enabled correctly after the task completes or faults.

        return overallSuccess; // Return success status
    }

    /// <summary>
    /// Gets the output path for the automated raw report generation, using a specific date.
    /// Ensures the directory exists.
    /// </summary>
    /// <param name="reportType">The report type index (should be DailyReportIndex).</param>
    /// <param name="reportDate">The date the report is for (e.g., previous workday).</param>
    /// <returns>The full path for the raw report.</returns>
    private static string GetAutomatedReportOutputPath(int reportType, DateTime reportDate)
    {
        // Replicates logic from ReportOutputLocation property but uses specified date
        string baseDir = $@"C:\Users\{Environment.UserName}\Harlow Printing\IT Projects - Documents\Dashboard Datasets\Raw_data\Quotes conversion\Estimate Reports Exports";
        // *** Use the provided reportDate for the filename ***
        string fileName = $"{reportDate:yyyyMMdd}_EstimateSuccessReport_Raw.xlsx";
        string subFolder = reportType switch // Simplified switch for clarity
        {
            DailyReportIndex => "Daily Reports",
            _ => "Other Reports", // Should not happen for auto-run
        };
        string fullPath = Path.Combine(baseDir, subFolder, fileName);
        try
        {
            Directory.CreateDirectory(Path.GetDirectoryName(fullPath)!);
        }
        catch (Exception ex) { Logger.LogError($"Auto Run: Failed to create raw output directory '{Path.GetDirectoryName(fullPath)}': {ex.Message}"); }
        return fullPath;
    }

    /// <summary>
    /// Gets the template path for the automated run.
    /// </summary>
    /// <param name="reportType">The report type index (should be DailyReportIndex).</param>
    /// <returns>The full path to the template file.</returns>
    private static string GetAutomatedTemplatePath(int reportType)
    {
        // Replicates logic from ExcelTemplateLocation property
        string baseDir = $@"C:\Users\{Environment.UserName}\Harlow Printing\IT Projects - Documents\Dashboard Datasets\Raw_data\Quotes conversion\TEMPLATE\";
        string templateName = reportType switch
        {
            // Daily uses the default weekly template
            _ => "TEMPLATE_Estimate Success Rate.xlsx"
        };
        return Path.Combine(baseDir, templateName);
    }

    /// <summary>
    /// Generates the email subject and body specifically for the automated daily run.
    /// </summary>
    /// <param name="reportType">The report type index (should be DailyReportIndex).</param>
    /// <param name="reportDate">The date the report was generated for (previous workday).</param>
    /// <returns>A tuple containing the email Subject string and the email Body string.</returns>
    private static (string Subject, string Body) GetEmailSubjectAndBodyForAutoRun(int reportType, DateTime reportDate)
    {
        string reportTypeName = "Estimate Success Rate";
        // Greeting depends on build mode (matches recipient logic in RunAutomatedDailyReportAsync)
        string greeting = IsDebug ? "Hi Debug," : "Hi Paul,";
        // *** Use the actual reportDate for the description ***
        string dateRangeInfo = $"for {reportDate:dd MMM yyyy}";
        string subjectPrefix = $"Daily {reportTypeName}"; // Always Daily for auto-run

        // *** Include the actual reportDate in the subject ***
        string subject = $"AUTOMATED: {subjectPrefix} Report ({reportDate:yyyy-MM-dd})"; // Indicate automated run and report date
        string body = $"{greeting}\n\nPlease find attached the automated {subjectPrefix} report {dateRangeInfo}.\n\nThank you,\nAutomation Service";

        return (subject, body);
    }

    /// <summary>
    /// Reads the last run date from the appsettings.json file.
    /// </summary>
    private void ReadLastRunDate()
    {
        try
        {
            if (!File.Exists(_appSettingsPath))
            {
                Logger.LogWarning($"appsettings.json not found at '{_appSettingsPath}'. Cannot read LastRunDate.");
                return;
            }

            string jsonContent = File.ReadAllText(_appSettingsPath);
            var json = JObject.Parse(jsonContent);

            // Navigate to the AutoReport section and get the LastRunDate value
            string? dateString = json?["AutoReport"]?["LastRunDate"]?.ToString();

            if (!string.IsNullOrEmpty(dateString))
            {
                // Try parsing the date using a specific format (ISO 8601 recommended)
                if (DateTime.TryParseExact(dateString, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime parsedDate))
                {
                    _lastAutoRunDate = parsedDate.Date; // Store only the date part
                    Logger.LogInfo($"Successfully read LastRunDate from appsettings.json: {_lastAutoRunDate:yyyy-MM-dd}");
                }
                else
                {
                    Logger.LogWarning($"Could not parse LastRunDate ('{dateString}') from appsettings.json using yyyy-MM-dd format. Using default MinValue.");
                    _lastAutoRunDate = DateTime.MinValue;
                }
            }
            else
            {
                Logger.LogInfo("LastRunDate is empty or not found in appsettings.json. Using default MinValue.");
                _lastAutoRunDate = DateTime.MinValue;
            }
        }
        catch (JsonReaderException jsonEx)
        {
            Logger.LogError($"Error reading or parsing JSON from '{_appSettingsPath}': {jsonEx.Message}");
            _lastAutoRunDate = DateTime.MinValue; // Default on error
        }
        catch (Exception ex)
        {
            Logger.LogError($"Failed to read LastRunDate from '{_appSettingsPath}': {ex.Message}");
            _lastAutoRunDate = DateTime.MinValue; // Default on error
        }
    }

    /// <summary>
    /// Saves the last run date to the appsettings.json file.
    /// Note: Modifying appsettings.json at runtime is generally discouraged.
    /// Consider using a separate state file if possible.
    /// </summary>
    /// <param name="dateToSave">The date to save (should be the date the run was *triggered*).</param>
    private void SaveLastRunDate(DateTime dateToSave)
    {
        try
        {
            if (!File.Exists(_appSettingsPath))
            {
                Logger.LogError($"appsettings.json not found at '{_appSettingsPath}'. Cannot save LastRunDate.");
                return;
            }

            string jsonContent = File.ReadAllText(_appSettingsPath);
            var json = JObject.Parse(jsonContent);

            // Ensure the AutoReport section exists
            if (json["AutoReport"] == null)
            {
                json["AutoReport"] = new JObject();
            }
            else if (json["AutoReport"] is not JObject) // Handle case where it exists but isn't an object
            {
                Logger.LogWarning("AutoReport section in appsettings.json is not a JSON object. Overwriting.");
                json["AutoReport"] = new JObject();
            }

            // Update the LastRunDate property, formatting as yyyy-MM-dd
            ((JObject)json["AutoReport"]!)["LastRunDate"] = dateToSave.ToString("yyyy-MM-dd");

            // Write the modified JSON back to the file
            // Use indented formatting for readability
            File.WriteAllText(_appSettingsPath, json.ToString(Formatting.Indented));

            Logger.LogInfo($"Successfully saved LastRunDate ({dateToSave:yyyy-MM-dd}) to appsettings.json");
        }
        catch (JsonReaderException jsonEx)
        {
            Logger.LogError($"Error reading or parsing JSON from '{_appSettingsPath}' during save: {jsonEx.Message}");
        }
        catch (IOException ioEx)
        {
            Logger.LogError($"IO Error saving LastRunDate to '{_appSettingsPath}': {ioEx.Message}. Check file permissions.");
            FlexibleMessageBox.Show($"Could not save the last run date to the settings file.\n\nPlease check application permissions for the directory:\n{Path.GetDirectoryName(_appSettingsPath)}\n\nError: {ioEx.Message}",
                            "File Write Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }
        catch (Exception ex)
        {
            Logger.LogError($"Failed to save LastRunDate to '{_appSettingsPath}': {ex.Message}");
        }
    }

    /// <summary>
    /// Disables primary UI controls during automated report execution.
    /// </summary>
    private void DisableControlsForAutoRun()
    {
        Logger.LogDebug("Disabling controls for Auto Run.");
        SafeControlUpdate(this, () =>
        {
            createReportButton.Enabled = false;
            processEmailButton.Enabled = false;
            toggleAutoRunButton.Enabled = false; // Disable toggling during run
            reportTypeComboBox.Enabled = false;
            startDatePicker.Enabled = false;
            endDatePicker.Enabled = false;
            financialYearComboBox.Enabled = false;
            sendToFemiOnlyCheckBox.Enabled = false;
            viewReportButton.Enabled = false; // Also disable view buttons
            viewAnalysisButton.Enabled = false;
            // Keep menu items enabled (like Help, Dark Mode)
        });
    }

    /// <summary>
    /// Re-enables primary UI controls after automated report execution attempt.
    /// Resets button states based on the outcome (similar to ResetUIOnError).
    /// </summary>
    private void EnableControlsAfterAutoRun()
    {
        Logger.LogDebug("Re-enabling controls after Auto Run.");

        // Reset UI to initial state for manual use, respecting config validity
        ResetUIOnError("Create Report");
    }


    #endregion

    #region Helper Methods (UI Updates, Validation, File Handling, etc.)

    // --- UI Update Helpers ---

    /// <summary>
    /// Safely updates a control's property or state by executing an action.
    /// Automatically marshals the call to the UI thread if required.
    /// Handles potential errors during invocation or if the control is disposed.
    /// </summary>
    /// <param name="ctrl">The control to update.</param>
    /// <param name="action">The action to perform on the control.</param>
    private static void SafeControlUpdate(Control ctrl, Action action)
    {
        ArgumentNullException.ThrowIfNull(action);
        // Check if control is valid and has a handle before attempting update
        if (ctrl == null || ctrl.IsDisposed || !ctrl.IsHandleCreated)
        {
            // Logger.LogWarning($"Control '{ctrl?.Name ?? "Unknown"}' not available for update."); // Can be noisy, disable if needed
            return; // Ignore update if control is not valid
        }

        // Check if the current thread is different from the UI thread
        if (ctrl.InvokeRequired)
        {
            try
            {
                // Use BeginInvoke for asynchronous execution on the UI thread (doesn't wait)
                ctrl.BeginInvoke(action);
            }
            // Ignore errors if control gets disposed while invoke is pending
            catch (ObjectDisposedException) { /* Ignore */ }
            // Ignore specific InvalidOperationException related to invoke on disposed handles
            catch (InvalidOperationException ex) when (ex.Message.Contains("Invoke") || ex.Message.Contains("Handle"))
            { Logger.LogWarning($"SafeControlUpdate ignored invoke/handle error: {ex.Message}"); }
            catch (Exception ex) // Catch other potential errors during invoke
            { Logger.LogError($"Unexpected error during SafeControlUpdate Invoke/BeginInvoke: {ex}"); }
        }
        else // Already on the UI thread
        {
            try { action(); /* Execute the action directly */ }
            catch (Exception ex) // Catch errors during direct execution
            { Logger.LogError($"Unexpected error during SafeControlUpdate direct action: {ex}"); }
        }
    }

    /// <summary>
    /// Updates the text of the main status label (statusLabel) on the left side of the status strip.
    /// </summary>
    /// <param name="message">The status message to display.</param>
    private void UpdateStatusMain(string message)
    {
        SafeControlUpdate(mainStatusStrip, () => // Use mainStatusStrip for InvokeRequired check
        {
            // Update the specific label by name
            if (statusLabel != null && !statusLabel.IsDisposed)
            {
                statusLabel.Text = message;
            }
        });
    }

    /// <summary>
    /// Updates the text of the auto run status label (autoRunStatusLabel) on the right side of the status strip.
    /// </summary>
    /// <param name="message">The status message to display.</param>
    private void UpdateStatusRight(string message)
    {
        SafeControlUpdate(mainStatusStrip, () => // Use mainStatusStrip for InvokeRequired check
        {
            // Update the specific label by name
            if (autoRunStatusLabel != null && !autoRunStatusLabel.IsDisposed)
            {
                autoRunStatusLabel.Text = message;
            }
        });
    }


    /// <summary>
    /// Enables or disables the main action buttons (Create Report, Process & Email) safely.
    /// Leaves other controls (like AutoRun toggle) untouched.
    /// </summary>
    /// <param name="enable">True to enable, false to disable.</param>
    private void SetActionButtonsEnabled(bool enable)
    {
        SafeControlUpdate(createReportButton, () => { createReportButton.Enabled = enable; });
        SafeControlUpdate(processEmailButton, () => { processEmailButton.Enabled = enable; });
        // Note: toggleAutoRunButton is NOT changed here
    }

    /// <summary>
    /// Enables or disables secondary input controls (dropdowns, date pickers, checkboxes, view buttons) safely.
    /// Financial Year dropdown is only enabled if it's currently visible.
    /// </summary>
    /// <param name="enable">True to enable, false to disable.</param>
    private void SetOtherControlsEnabled(bool enable)
    {
        SafeControlUpdate(reportTypeComboBox, () => { reportTypeComboBox.Enabled = enable; });
        SafeControlUpdate(startDatePicker, () => { startDatePicker.Enabled = enable; });
        SafeControlUpdate(endDatePicker, () => { endDatePicker.Enabled = enable; });
        SafeControlUpdate(financialYearComboBox, () => { financialYearComboBox.Enabled = enable && financialYearComboBox.Visible; });
        SafeControlUpdate(sendToFemiOnlyCheckBox, () => { sendToFemiOnlyCheckBox.Enabled = enable; });
        // Also enable/disable view buttons here for consistency
        SafeControlUpdate(viewReportButton, () => { viewReportButton.Enabled = enable; });
        SafeControlUpdate(viewAnalysisButton, () => { viewAnalysisButton.Enabled = enable; });
    }


    /// <summary>
    /// Resets the UI to an initial state, typically after an error, cancellation, or completion of a manual run.
    /// Re-enables controls, resets button text, and updates visibility/enabled state of view buttons based on file existence.
    /// Schedules the main status label to reset to "Ready" after a delay.
    /// </summary>
    /// <param name="button1Text">Text to set for Button 1 (e.g., "Create Report", "Error", "Cancelled"). Defaults to "Create Report".</param>
    private void ResetUIOnError(string button1Text = "Create Report")
    {
        SafeControlUpdate(this, () =>
        {
            Logger.LogDebug($"Resetting UI state. Button 1 text: '{button1Text}'");

            // --- Determine current state ---
            bool configValid = !(string.IsNullOrEmpty(CrystalReportLocation) || !File.Exists(CrystalReportLocation) || string.IsNullOrEmpty(WrapperExePath) || !File.Exists(WrapperExePath));
            bool rawReportExists = !string.IsNullOrEmpty(_generatedReportPath) && File.Exists(_generatedReportPath);
            bool analysisExists = !string.IsNullOrEmpty(_generatedAnalysisFilePath) && File.Exists(_generatedAnalysisFilePath);

            // --- Enable/Disable Primary Buttons ---
            createReportButton.Enabled = configValid; // Enable if config is ok
            createReportButton.Text = configValid ? button1Text : "Config Error";

            processEmailButton.Enabled = rawReportExists; // Enable only if raw report exists
            processEmailButton.Text = "Process and Email";

            // Ensure Auto Run toggle button is always enabled after manual operations/resets
            toggleAutoRunButton.Enabled = true;

            // --- Enable Other Controls ---
            SetOtherControlsEnabled(true); // Enable dropdowns, date pickers, checkboxes, view buttons

            // --- Update Visibility and Enabled state for View buttons ---
            // Keep visible and enabled if the corresponding file exists
            viewReportButton.Visible = rawReportExists;
            viewReportButton.Enabled = rawReportExists;

            viewAnalysisButton.Visible = analysisExists;
            viewAnalysisButton.Enabled = analysisExists;

            // --- Update Femi/Paul labels ---
            bool isDailySelected = (reportTypeComboBox.SelectedIndex == DailyReportIndex);
            sendToFemiOnlyCheckBox.Visible = !isDailySelected;
            emailRecipientLabel.Visible = isDailySelected;
            if (isDailySelected) emailRecipientLabel.Text = "Emailing Daily report to Paul";

            // --- Update Status ---
            // Reset AutoRun UI based on timer state (important after error/completion)
            UpdateAutoRunUI(dailyCheckTimer.Enabled);

            // Schedule main status reset to "Ready" after a delay, allowing user to see the final message
            string currentMainStatus = statusLabel.Text ?? string.Empty;
            // Only schedule reset if the current status isn't already "Ready" and isn't an active Auto Run message
            if (currentMainStatus != "Ready" && !currentMainStatus.StartsWith("Auto Run:"))
            {
                _ = Task.Delay(5000).ContinueWith(t => {
                    // Check again before resetting, in case another operation started or status changed
                    string statusNow = statusLabel.Text ?? string.Empty;
                    // Only reset if the status hasn't changed in the meantime and isn't an active Auto Run message
                    if (statusNow == currentMainStatus && !statusNow.StartsWith("Auto Run:"))
                    {
                        UpdateStatusMain("Ready");
                    }
                }, TaskScheduler.FromCurrentSynchronizationContext());
            }
            // If it was an Auto Run message, it will be reset to Ready in the timer's finally block.
        });
    }


    /// <summary>
    /// Sets the UI state after the entire process (including emailing) completes successfully for a *manual* run.
    /// Updates the status label and calls ResetUIOnError to handle control states and schedule the final status reset.
    /// Specifically sets the Create Report button to enabled and Process/Email button to disabled.
    /// </summary>
    private void SetUICompleted()
    {
        // Update status first to show completion message
        UpdateStatusMain("Process Completed Successfully.");
        // Call ResetUIOnError to reset most controls and schedule the "Ready" status update
        ResetUIOnError("Create Report"); // This will enable Create Report if config is valid

        // Explicitly set button states AFTER ResetUIOnError for the specific completed state
        SafeControlUpdate(this, () => {
            bool configValid = !(string.IsNullOrEmpty(CrystalReportLocation) || !File.Exists(CrystalReportLocation) || string.IsNullOrEmpty(WrapperExePath) || !File.Exists(WrapperExePath));
            createReportButton.Enabled = configValid; // Ensure Create is enabled (if config valid)
            processEmailButton.Enabled = false; // Ensure Process is disabled
                                                // View buttons visibility/enabled state is handled by ResetUIOnError based on file existence
        });
    }


    /// <summary>
    /// Resets the state of Button 1 and Button 2 when the report type changes.
    /// Forces the user to click Button 1 again for the new report type.
    /// Clears stored file paths and hides view buttons.
    /// </summary>
    private void ResetButtonStatesAfterTypeChange()
    {
        SafeControlUpdate(this, () =>
        {
            Logger.LogDebug("Resetting button states due to report type change.");
            // Enable Button 1 only if config paths are valid
            bool configValid = !(string.IsNullOrEmpty(CrystalReportLocation) || !File.Exists(CrystalReportLocation) || string.IsNullOrEmpty(WrapperExePath) || !File.Exists(WrapperExePath));
            createReportButton.Enabled = configValid;
            createReportButton.Text = configValid ? "Create Report" : "Config Error";

            processEmailButton.Text = "Process and Email";
            processEmailButton.Enabled = false; // Always disable Button 2 on type change

            // Hide and disable view buttons on type change
            viewReportButton.Visible = false;
            viewReportButton.Enabled = false;
            viewAnalysisButton.Visible = false;
            viewAnalysisButton.Enabled = false;

            _generatedReportPath = string.Empty; // Clear paths
            _generatedAnalysisFilePath = string.Empty;
            UpdateStatusMain("Ready"); // Reset status
        });
    }


    /// <summary>
    /// Safely shows or hides the "View Analysis" button (viewAnalysisButton).
    /// Also ensures it's enabled when shown.
    /// </summary>
    /// <param name="show">True to make the button visible, false to hide it.</param>
    private void ShowViewAnalysisButton(bool show)
    {
        SafeControlUpdate(viewAnalysisButton, () =>
        {
            viewAnalysisButton.Visible = show;
            viewAnalysisButton.Enabled = show; // Enable when visible
        });
    }

    // --- Validation Helpers ---
    /// <summary>Validates that the 'From' date is not after the 'To' date.</summary>
    private bool ValidateInputDates()
    {
        if (startDatePicker.Value.Date > endDatePicker.Value.Date) // Compare Date parts only
        {
            Logger.LogError("Validation Failed: 'From' date cannot be after 'To' date.");
            FlexibleMessageBox.Show("The 'From' date cannot be after the 'To' date.", "Date Range Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            return false;
        }
        return true;
    }
    /// <summary>Validates if the selected date range falls within the selected Financial Year (if applicable).</summary>
    private bool ValidateFinancialYearSelection()
    {
        if (financialYearComboBox.Visible && financialYearComboBox.SelectedItem != null) // Use correct name
        {
            string selectedFinYear = financialYearComboBox.SelectedItem.ToString()!; // Use correct name
            if (!ExcelCopyData.IsFinancialYearValid(selectedFinYear, startDatePicker.Value, endDatePicker.Value)) // Use correct name
            {
                Logger.LogWarning($"Potential FY mismatch: Selected FY '{selectedFinYear}', Date Range '{startDatePicker.Value:d}' to '{endDatePicker.Value:d}'. Prompting user."); // Use correct name
                DialogResult dr = FlexibleMessageBox.Show($"The selected date range ({startDatePicker.Value:d} - {endDatePicker.Value:d}) does not fall entirely within the selected Financial Year ({selectedFinYear}).\n\nDo you want to continue anyway?", "Financial Year Mismatch Warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning); // Use correct name
                if (dr == DialogResult.No) { Logger.LogInfo("User chose not to proceed due to FY mismatch."); return false; }
                Logger.LogWarning("User chose to proceed despite FY mismatch warning.");
            }
        }
        return true;
    }

    // --- File Handling Helper ---
    /// <summary>Opens the specified file using the default system application.</summary>
    private static void OpenFileHelper(string filePath, string fileTypeDescription)
    {
        Logger.LogInfo($"Attempting to open {fileTypeDescription}: {filePath}");
        try
        {
            if (!File.Exists(filePath))
            {
                Logger.LogWarning($"{Capitalize(fileTypeDescription)} file not found at path: {filePath}");
                FlexibleMessageBox.Show($"{Capitalize(fileTypeDescription)} file was not found:\n{filePath}", "File Not Found", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }
            Process.Start(new ProcessStartInfo(filePath) { UseShellExecute = true });
            Logger.LogInfo($"Successfully initiated opening of {fileTypeDescription} file.");
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error opening {fileTypeDescription} file '{filePath}': {ex}");
            FlexibleMessageBox.Show($"Could not open the {fileTypeDescription} file.\nError: {ex.Message}", "File Open Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }
    }

    // --- Date Calculation Helpers ---

    /// <summary>
    /// Calculates the previous working day (Monday -> Friday, otherwise Day - 1).
    /// </summary>
    /// <param name="currentDate">The date to calculate from (usually Today).</param>
    /// <returns>The DateTime representing the previous workday.</returns>
    private static DateTime GetPreviousWorkday(DateTime currentDate)
    {
        DateTime previousDay = currentDate.AddDays(-1);
        return currentDate.DayOfWeek switch
        {
            DayOfWeek.Monday => currentDate.AddDays(-3),// If today is Monday, go back 3 days to Friday
            DayOfWeek.Sunday => currentDate.AddDays(-2),// If today is Sunday, go back 2 days to Friday
            _ => previousDay,// Otherwise (Tue-Sat), just go back 1 day
        };
    }

    /// <summary>Calculates the date range for the Monthly report type.</summary>
    private static (DateTime DateFrom, DateTime DateTo, bool ShowFinYear) CalculateMonthlyRange(DateTime today)
    {
        DateTime dateFrom, dateTo;
        // Calculate based on the *previous* month if today is early in the current month
        if (today.Day <= 15)
        {
            // End date is the last day of the previous month
            DateTime firstDayOfCurrentMonth = new(today.Year, today.Month, 1);
            dateTo = firstDayOfCurrentMonth.AddDays(-1);
            // Start date is the first day of the previous month
            dateFrom = dateTo.AddDays(1).AddMonths(-1);
        }
        else // Otherwise, use the current month up to today
        {
            dateFrom = new DateTime(today.Year, today.Month, 1);
            dateTo = today; // End date is today
        }
        return (dateFrom, dateTo, false);
    }
    /// <summary>Calculates the date range for the Quarterly report type.</summary>
    private static (DateTime DateFrom, DateTime DateTo, bool ShowFinYear) CalculateQuarterlyRange(DateTime today)
    {
        // Report for the *previous* full quarter
        int currentQuarter = (today.Month - 1) / 3 + 1;
        // First day of the current quarter
        DateTime firstDayOfCurrentQuarter = new(today.Year, (currentQuarter - 1) * 3 + 1, 1);
        // End date is the day before the current quarter started (last day of previous quarter)
        DateTime dateTo = firstDayOfCurrentQuarter.AddDays(-1);
        // Start date is the first day of the previous quarter
        DateTime dateFrom = firstDayOfCurrentQuarter.AddMonths(-3);
        return (dateFrom, dateTo, false);
    }

    // --- String Helpers ---
    /// <summary>Capitalizes the first letter of a string.</summary>
    private static string Capitalize(string text) { return string.IsNullOrEmpty(text) ? text : char.ToUpperInvariant(text[0]) + text[1..]; }
    /// <summary>Gets the quarter number string (e.g., "Q1") for a given date.</summary>
    private static string GetQuarterString(DateTime date) { return $"Q{(date.Month - 1) / 3 + 1}"; }

    // --- Dropdown Population ---
    /// <summary>Populates the Financial Year dropdown with the current and previous financial years.</summary>
    private void PopulateFinancialYearDropdown()
    {
        SafeControlUpdate(financialYearComboBox, () => // Use correct name
        {
            financialYearComboBox.Items.Clear(); // Use correct name
            string currentFY = _financialYear;
            if (!string.IsNullOrEmpty(currentFY))
            {
                financialYearComboBox.Items.Add(currentFY); // Use correct name
                string? previousFY = ExcelCopyData.GetPreviousFinancialYear(currentFY);
                if (!string.IsNullOrEmpty(previousFY)) { financialYearComboBox.Items.Add(previousFY); } // Use correct name
            }
            else { Logger.LogWarning("Could not determine current financial year for dropdown population."); financialYearComboBox.Items.Add("FY Unknown"); } // Use correct name
            if (financialYearComboBox.Items.Count > 0) { financialYearComboBox.SelectedIndex = 0; } // Use correct name
        });
    }

    // --- Theme Detection ---
    /// <summary>
    /// Checks the Windows Registry to determine if the Apps theme is set to dark mode.
    /// </summary>
    /// <returns>True if dark mode is enabled for apps, false otherwise (or if key is not found).</returns>
    private static bool IsWindowsDarkModeEnabled()
    {
        try
        {
            // The key responsible for app theme (1 = Light, 0 = Dark)
            const string keyPath = @"HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize";
            const string valueName = "AppsUseLightTheme";

            object? registryValue = Registry.GetValue(keyPath, valueName, 1); // Default to 1 (Light) if not found

            if (registryValue is int intValue)
            {
                return intValue == 0; // Dark mode is enabled if the value is 0
            }
        }
        catch (Exception ex)
        {
            // Log error accessing registry, default to light mode
            Logger.LogError($"Error reading Windows theme setting from registry: {ex.Message}");
        }

        // Default to Light mode if registry key is inaccessible or value is unexpected type
        return false;
    }

    #endregion
}